[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/contracts/AbstractContract.js",
    "content": "import _ from 'lodash'\n\nimport isRequired from '../utils/isRequired'\nimport delegateCalls from '../utils/delegateCalls'\n\n/**\n * Abstract Contract holds a contract implementation to make calls to the blockchain but\n * also includes methods that interact with the off chain store. NOTE all methods that\n * the underlying contract implementation expose can be called directly from an Abstract contract.\n */\nclass AbstractContract {\n  /**\n   * AbstractContract wraps an implementation instance to provide access to higher level\n   * services such as an off chain store, as well as the functionality of the underlying\n   * implementation.\n   * @param {object} implementationInstance - Contract Implementation object to extend\n   * @param {object} storeProviderInstance - StoreProvider wrapper object.\n   */\n  constructor(\n    implementationInstance = isRequired('implementationInstance'),\n    storeProviderInstance = isRequired('storeProviderInstance')\n  ) {\n    this._StoreProvider = storeProviderInstance\n    this._contractImplementation = implementationInstance\n    delegateCalls(this, implementationInstance)\n  }\n\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProvider = storeProviderInstance\n  }\n}\n\nexport default AbstractContract\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/AbstractContract.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "AbstractContract",
    "memberof": "src/contracts/AbstractContract.js",
    "static": true,
    "longname": "src/contracts/AbstractContract.js~AbstractContract",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/AbstractContract.js",
    "importStyle": "AbstractContract",
    "description": "Abstract Contract holds a contract implementation to make calls to the blockchain but\nalso includes methods that interact with the off chain store. NOTE all methods that\nthe underlying contract implementation expose can be called directly from an Abstract contract.",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#constructor",
    "access": "public",
    "description": "AbstractContract wraps an implementation instance to provide access to higher level\nservices such as an off chain store, as well as the functionality of the underlying\nimplementation.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "implementationInstance",
        "description": "Contract Implementation object to extend"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "StoreProvider wrapper object."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "_StoreProvider",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#_StoreProvider",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "_contractImplementation",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#_contractImplementation",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/contracts/AbstractContract.js~AbstractContract",
    "static": false,
    "longname": "src/contracts/AbstractContract.js~AbstractContract#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/contracts/ContractImplementation.js",
    "content": "import contract from 'truffle-contract'\nimport _ from 'lodash'\n\nimport isRequired from '../utils/isRequired'\nimport * as errorConstants from '../constants/error'\nimport Web3Wrapper from '../utils/Web3Wrapper'\n\n/**\n * ContractImplementation is a parent class for on chain contracts. It loads the contract from the\n * blockchain and exposes the contract instance for use by the child.\n */\nclass ContractImplementation {\n  constructor(\n    web3Provider = isRequired('web3Provider'),\n    artifact = isRequired('artifact'),\n    contractAddress\n  ) {\n    this.contractAddress = contractAddress\n    this.artifact = artifact\n    this.contractInstance = null\n    this._Web3Wrapper = new Web3Wrapper(web3Provider)\n    // loading params\n    this._contractLoadedResolver = null\n    this._contractLoadedRejecter = null\n    this._loadingContractInstance = null\n    this.isLoading = false\n  }\n\n  /**\n   * Load contract instance if not yet initialized. Returns loading promise\n   * @returns {Promise} resolves to contractInstance\n   */\n  loadContract = async () => {\n    if (this.isLoading) return this._loadingContractInstance\n    if (this.contractInstance) return this.contractInstance\n\n    if (!this.contractAddress || !this.artifact)\n      throw new Error(errorConstants.CONTRACT_INSTANCE_NOT_SET)\n\n    const newLoadingPromise = this._newLoadingPromise()\n    this._loadingContractInstance = newLoadingPromise\n    this._load()\n    return newLoadingPromise\n  }\n\n  /**\n   * Get the web3 provider object from the initialized web3 instance\n   * @returns {object} web3 provider object\n   */\n  getWeb3Provider = () => this._Web3Wrapper.getProvider()\n\n  /**\n   * MetaMask safe get block data by blockNumber\n   * @param {Int} blockNumber - Block number\n   * @returns {Promise} block object\n   */\n  getBlock = async blockNumber => this._Web3Wrapper.getBlock(blockNumber)\n\n  /**\n   * Set a new contract instance\n   * @param {string} contractAddress - The address of the contract\n   * @param {object} artifact - Contract artifact to use to load contract\n   * @returns {object} contractInstance object\n   */\n  setContractInstance = async (\n    contractAddress = this.contractAddress,\n    artifact = this.artifact\n  ) => {\n    this.contractAddress = contractAddress\n    this.artifact = artifact\n    this.contractInstance = null\n    return this.loadContract()\n  }\n\n  /**\n   * Load an existing contract from the current artifact and address\n   */\n  _load = async () => {\n    this.isLoading = true\n    try {\n      this.contractInstance = await this._instantiateContractIfExistsAsync(\n        this.artifact,\n        this.contractAddress\n      )\n\n      this.isLoading = false\n      this._contractLoadedResolver(this.contractInstance)\n    } catch (err) {\n      this.isLoading = false\n      this._contractLoadedRejecter(err)\n    }\n  }\n\n  /**\n   * Instantiate contract.\n   * @private\n   * @param {object} artifact - The contract artifact.\n   * @param {string} address - The hex encoded contract Ethereum address\n   * @returns {object} - The contract instance.\n   */\n  _instantiateContractIfExistsAsync = async (artifact, address) => {\n    try {\n      const c = await contract(artifact)\n      await c.setProvider(await this._Web3Wrapper.getProvider())\n      const contractInstance = _.isUndefined(address)\n        ? await c.deployed()\n        : await c.at(address)\n\n      // Estimate gas before sending transactions\n      for (const funcABI of contractInstance.abi) {\n        // Check for non-constant functions\n        if (funcABI.type === 'function' && funcABI.constant === false) {\n          const func = contractInstance[funcABI.name]\n\n          // eslint-disable-next-line no-loop-func\n          contractInstance[funcABI.name] = async (...args) => {\n            await func.estimateGas(...args) // Estimate gas (also checks for possible failures)\n            return func(...args) // Call original function\n          }\n\n          // Keep reference to the original function for special cases\n          contractInstance[funcABI.name].original = func\n\n          // Forward other accessors to the original function\n          Object.setPrototypeOf(contractInstance[funcABI.name], func)\n        }\n      }\n\n      return contractInstance\n    } catch (err) {\n      console.error(err)\n\n      if (_.includes(err.message, 'not been deployed to detected network'))\n        throw new Error(errorConstants.CONTRACT_NOT_DEPLOYED)\n\n      throw new Error(errorConstants.UNABLE_TO_LOAD_CONTRACT)\n    }\n  }\n\n  /**\n   * Create a new Promise to be used in loading the contract.\n   * @returns {Promise} - Resolves to contract instance.\n   */\n  _newLoadingPromise = () =>\n    new Promise((resolve, reject) => {\n      this._contractLoadedResolver = resolve\n      this._contractLoadedRejecter = reject\n    })\n\n  /**\n   * Get the contract address for the currently instantiated contract.\n   * @returns {string} - The address of the contract.\n   */\n  getContractAddress = () => this.contractAddress\n\n  /**\n   * Returns the web3 wrapper\n   * @returns {object} - Web3 Wrapper\n   */\n  getWeb3Wrapper = () => this._Web3Wrapper\n}\n\nexport default ContractImplementation\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/ContractImplementation.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "class",
    "name": "ContractImplementation",
    "memberof": "src/contracts/ContractImplementation.js",
    "static": true,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/ContractImplementation.js",
    "importStyle": "ContractImplementation",
    "description": "ContractImplementation is a parent class for on chain contracts. It loads the contract from the\nblockchain and exposes the contract instance for use by the child.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 57,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "contractAddress",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#contractAddress",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "artifact",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#artifact",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "contractInstance",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#contractInstance",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "_Web3Wrapper",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_Web3Wrapper",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_contractLoadedResolver",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_contractLoadedResolver",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_contractLoadedRejecter",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_contractLoadedRejecter",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "_loadingContractInstance",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_loadingContractInstance",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "isLoading",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#isLoading",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "loadContract",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#loadContract",
    "access": "public",
    "description": "Load contract instance if not yet initialized. Returns loading promise",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} resolves to contractInstance"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "resolves to contractInstance"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "getWeb3Provider",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#getWeb3Provider",
    "access": "public",
    "description": "Get the web3 provider object from the initialized web3 instance",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "web3 provider object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "member",
    "name": "getBlock",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#getBlock",
    "access": "public",
    "description": "MetaMask safe get block data by blockNumber",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} block object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Int"
        ],
        "spread": false,
        "optional": false,
        "name": "blockNumber",
        "description": "Block number"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "block object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "setContractInstance",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#setContractInstance",
    "access": "public",
    "description": "Set a new contract instance",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} contractInstance object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "The address of the contract"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "artifact",
        "description": "Contract artifact to use to load contract"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "contractInstance object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "_load",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_load",
    "access": "private",
    "description": "Load an existing contract from the current artifact and address",
    "lineNumber": 78,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "_instantiateContractIfExistsAsync",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_instantiateContractIfExistsAsync",
    "access": "private",
    "description": "Instantiate contract.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The contract instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "artifact",
        "description": "The contract artifact."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "address",
        "description": "The hex encoded contract Ethereum address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The contract instance."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "_newLoadingPromise",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#_newLoadingPromise",
    "access": "private",
    "description": "Create a new Promise to be used in loading the contract.",
    "lineNumber": 144,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Resolves to contract instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves to contract instance."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "getContractAddress",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#getContractAddress",
    "access": "public",
    "description": "Get the contract address for the currently instantiated contract.",
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The address of the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The address of the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "getWeb3Wrapper",
    "memberof": "src/contracts/ContractImplementation.js~ContractImplementation",
    "static": false,
    "longname": "src/contracts/ContractImplementation.js~ContractImplementation#getWeb3Wrapper",
    "access": "public",
    "description": "Returns the web3 wrapper",
    "lineNumber": 160,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Web3 Wrapper"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Web3 Wrapper"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "src/contracts/abstractions/Arbitrable.js",
    "content": "import Eth from 'ethjs'\n\nimport getContractAddress from '../../utils/getContractAddress'\nimport AbstractContract from '../AbstractContract'\n\n/**\n * Arbitrable Abstract Contarct API. This wraps an arbitrable contract. It provides\n * interaction with both the off chain store as well as the arbitrable instance. All\n * arbitrable methods from the supplied contract implementation can be called from this\n * object.\n */\nclass ArbitrableContract extends AbstractContract {\n  /**\n   * Deploy a contract and add to the Store.\n   * @param {string} account - Ethereum address.\n   * @param {int} value - funds to be placed in contract.\n   * @param {string} arbitratorAddress - The address of the arbitrator contract.\n   * @param {int} timeout - Time after which a party automatically loose a dispute.\n   * @param {string} partyB - Ethereum address of the other party in the contract.\n   * @param {bytes} arbitratorExtraData - Extra data for the arbitrator.\n   * @param {string} email - Email address of the contract creator (default empty string).\n   * @param {object} metaEvidence - The metaEvidence object associated with the Arbitarble Contract.\n   * @param {...any} args - Extra arguments for the contract.\n   * @returns {object | Error} - The contract object or an error.\n   */\n  deploy = async (\n    account,\n    value,\n    arbitratorAddress,\n    timeout,\n    partyB,\n    arbitratorExtraData = '',\n    email = '',\n    metaEvidence = {},\n    ...args\n  ) => {\n    const web3Provider = this._contractImplementation.getWeb3Provider()\n    const eth = new Eth(web3Provider)\n    const txCount = await eth.getTransactionCount(account)\n    // determine the contract address WARNING if the nonce changes this will produce a different address\n    const contractAddress = getContractAddress(account, txCount)\n    const metaEvidenceUri = this._StoreProvider.getMetaEvidenceUri(\n      account,\n      contractAddress\n    )\n    const contractInstance = await this._contractImplementation.constructor.deploy(\n      account,\n      value,\n      arbitratorAddress,\n      timeout,\n      partyB,\n      arbitratorExtraData,\n      metaEvidenceUri,\n      web3Provider,\n      ...args\n    )\n\n    if (contractInstance.address !== contractAddress)\n      throw new Error('Contract address does not match meta-evidence uri')\n\n    const newContract = await this._StoreProvider.updateContract(\n      account,\n      contractInstance.address,\n      {\n        partyA: account,\n        partyB,\n        email,\n        metaEvidence\n      }\n    )\n\n    return newContract\n  }\n\n  /**\n   * Submit evidence. FIXME should we determine the hash for the user?\n   * @param {string} account - ETH address of user.\n   * @param {string} name - Name of evidence.\n   * @param {string} description - Description of evidence.\n   * @param {string} url - A link to an evidence using its URI.\n   * @param {string} hash - A hash of the evidence at the URI. No hash if content is dynamic\n   * @returns {string} - txHash Hash transaction.\n   */\n  submitEvidence = async (account, name, description, url, hash) => {\n    const contractAddress = this._contractImplementation.contractAddress\n    // get the index of the new evidence\n    const evidenceIndex = await this._StoreProvider.addEvidenceContract(\n      contractAddress,\n      account,\n      name,\n      description,\n      url,\n      hash\n    )\n    // construct the unique URI\n    const evidenceUri = this._StoreProvider.getEvidenceUri(\n      account,\n      contractAddress,\n      evidenceIndex\n    )\n    const txHash = await this._contractImplementation.submitEvidence(\n      account,\n      evidenceUri\n    )\n\n    return txHash\n  }\n\n  /**\n   * Get all contracts TODO do we need to get contract data from blockchain?\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Contract data from store.\n   */\n  getContractsForUser = async account => {\n    // fetch user profile\n    const userProfile = await this._StoreProvider.newUserProfile(account)\n\n    return userProfile.contracts\n  }\n\n  /**\n   * Fetch all data from the store on the current contract.\n   * @returns {object} - Store data for contract.\n   */\n  getDataFromStore = async () => {\n    const contractInstance = await this._contractImplementation.loadContract()\n    const partyA = await contractInstance.partyA()\n\n    return this._StoreProvider.getContractByAddress(\n      partyA,\n      this._contractImplementation.contractAddress\n    )\n  }\n}\n\nexport default ArbitrableContract\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/abstractions/Arbitrable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "class",
    "name": "ArbitrableContract",
    "memberof": "src/contracts/abstractions/Arbitrable.js",
    "static": true,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/abstractions/Arbitrable.js",
    "importStyle": "ArbitrableContract",
    "description": "Arbitrable Abstract Contarct API. This wraps an arbitrable contract. It provides\ninteraction with both the off chain store as well as the arbitrable instance. All\narbitrable methods from the supplied contract implementation can be called from this\nobject.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "src/contracts/AbstractContract.js~AbstractContract"
    ]
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#deploy",
    "access": "public",
    "description": "Deploy a contract and add to the Store.",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object | Error} - The contract object or an error."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum address."
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "funds to be placed in contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "int"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Time after which a party automatically loose a dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "partyB",
        "description": "Ethereum address of the other party in the contract."
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorExtraData",
        "description": "Extra data for the arbitrator."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": "Email address of the contract creator (default empty string)."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "metaEvidence",
        "description": "The metaEvidence object associated with the Arbitarble Contract."
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Extra arguments for the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object ",
        " Error"
      ],
      "spread": false,
      "description": "The contract object or an error."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "submitEvidence",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#submitEvidence",
    "access": "public",
    "description": "Submit evidence. FIXME should we determine the hash for the user?",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - txHash Hash transaction."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "Description of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to an evidence using its URI."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "A hash of the evidence at the URI. No hash if content is dynamic"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "txHash Hash transaction."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "getContractsForUser",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#getContractsForUser",
    "access": "public",
    "description": "Get all contracts TODO do we need to get contract data from blockchain?",
    "lineNumber": 114,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Contract data from store."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Contract data from store."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "getDataFromStore",
    "memberof": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrable.js~ArbitrableContract#getDataFromStore",
    "access": "public",
    "description": "Fetch all data from the store on the current contract.",
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Store data for contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Store data for contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "file",
    "name": "src/contracts/abstractions/Arbitrator.js",
    "content": "import _ from 'lodash'\n\nimport * as arbitratorConstants from '../../constants/arbitrator'\nimport AbstractContract from '../AbstractContract'\nimport httpRequest from '../../utils/httpRequest'\nimport { DISPUTE_CACHE_URI } from '../../constants/dispute'\n/**\n * Arbitrator Abstract Contarct API. This wraps an arbitrator contract. It provides\n * interaction with both the off chain store as well as the arbitrator instance. All\n * arbitrator methods from the supplied contract implementation can be called from this\n * object.\n */\nclass Arbitrator extends AbstractContract {\n  /**\n   * Get disputes for user with extra data from arbitrated transaction and store\n   * @param {string} account Address of user\n   * @param {bool} allowOffChainCache Should open disputes be pulled from off chain cache.\n   * The cache is maintained by Kleros for performance. To pull open disputes from the blockchain\n   * set false\n   * @returns {object[]} dispute data objects for user\n   */\n  getDisputesForUser = async (account, allowOffChainCache = true) => {\n    // contract data\n    const [period, currentSession] = await Promise.all([\n      this._contractImplementation.getPeriod(),\n      this._contractImplementation.getSession()\n    ])\n\n    // new jurors have not been chosen yet. don't update\n    if (period !== arbitratorConstants.PERIOD.VOTE) {\n      return this.getDisputesForUserFromStore(account)\n    }\n\n    let profile = await this._StoreProvider.newUserProfile(account)\n    if (currentSession !== profile.session) {\n      // pull open disputes from off chain cache\n      let cachedDisputes = null\n      if (allowOffChainCache) {\n        const cachedDisputesResponse = await httpRequest(\n          'GET',\n          `${DISPUTE_CACHE_URI}/${currentSession}`\n        )\n\n        if (\n          cachedDisputesResponse.body &&\n          cachedDisputesResponse.body.open_disputes\n        ) {\n          cachedDisputes = await Promise.all(\n            cachedDisputesResponse.body.open_disputes.map(disputeIDString =>\n              this._contractImplementation.getDispute(Number(disputeIDString))\n            )\n          )\n        }\n      }\n\n      // get disputes for juror\n      const myDisputes = await this._contractImplementation.getDisputesForJuror(\n        account,\n        cachedDisputes\n      )\n\n      // update user profile for each dispute\n      await Promise.all(\n        myDisputes.map(async dispute => {\n          if (dispute.appealDraws[dispute.numberOfAppeals].length > 0) {\n            const disputeCreationLog = await this._contractImplementation.getDisputeCreationEvent(\n              dispute.disputeID\n            )\n\n            if (!disputeCreationLog)\n              throw new Error('Could not fetch dispute creation event log')\n            // update profile for account\n            await this._StoreProvider.updateDisputeProfile(\n              account,\n              dispute.arbitratorAddress,\n              dispute.disputeID,\n              {\n                blockNumber: disputeCreationLog.blockNumber\n              }\n            )\n            // add draws separately for appeals\n            await this._StoreProvider.addNewDrawsDisputeProfile(\n              account,\n              dispute.arbitratorAddress,\n              dispute.disputeID,\n              dispute.appealDraws[dispute.numberOfAppeals],\n              dispute.numberOfAppeals\n            )\n          }\n        })\n      )\n\n      // FIXME do we want to store session?\n      this._StoreProvider.updateUserSession(account, currentSession)\n    }\n\n    return this.getDisputesForUserFromStore(account)\n  }\n\n  /**\n   * Get disputes from the store.\n   * @param {string} account - The users account.\n   * @returns {object[]} The dispute objects.\n   */\n  getDisputesForUserFromStore = async account => {\n    const aribtratorAddress = this._contractImplementation.getContractAddress()\n    return Promise.all(\n      (await this._StoreProvider.getDisputes(account))\n        .filter(dispute => dispute.arbitratorAddress === aribtratorAddress)\n        .map(dispute =>\n          this._contractImplementation.getDispute(dispute.disputeId)\n        )\n    )\n  }\n\n  /**\n   * Buy PNK.\n   * @param {number} amount - Number of pinakion to buy.\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Balance of user.\n   */\n  buyPNK = async (amount, account) => {\n    await this._contractImplementation.buyPNK(amount, account)\n    return this._contractImplementation.getPNKBalance(account)\n  }\n}\n\nexport default Arbitrator\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/abstractions/Arbitrator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 92,
    "kind": "class",
    "name": "Arbitrator",
    "memberof": "src/contracts/abstractions/Arbitrator.js",
    "static": true,
    "longname": "src/contracts/abstractions/Arbitrator.js~Arbitrator",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/abstractions/Arbitrator.js",
    "importStyle": "Arbitrator",
    "description": "Arbitrator Abstract Contarct API. This wraps an arbitrator contract. It provides\ninteraction with both the off chain store as well as the arbitrator instance. All\narbitrator methods from the supplied contract implementation can be called from this\nobject.",
    "lineNumber": 13,
    "interface": false,
    "extends": [
      "src/contracts/AbstractContract.js~AbstractContract"
    ]
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "getDisputesForUser",
    "memberof": "src/contracts/abstractions/Arbitrator.js~Arbitrator",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrator.js~Arbitrator#getDisputesForUser",
    "access": "public",
    "description": "Get disputes for user with extra data from arbitrated transaction and store",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} dispute data objects for user"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user"
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "allowOffChainCache",
        "description": "Should open disputes be pulled from off chain cache.\nThe cache is maintained by Kleros for performance. To pull open disputes from the blockchain\nset false"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "dispute data objects for user"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "getDisputesForUserFromStore",
    "memberof": "src/contracts/abstractions/Arbitrator.js~Arbitrator",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrator.js~Arbitrator#getDisputesForUserFromStore",
    "access": "public",
    "description": "Get disputes from the store.",
    "lineNumber": 105,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} The dispute objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The users account."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "The dispute objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "buyPNK",
    "memberof": "src/contracts/abstractions/Arbitrator.js~Arbitrator",
    "static": false,
    "longname": "src/contracts/abstractions/Arbitrator.js~Arbitrator#buyPNK",
    "access": "public",
    "description": "Buy PNK.",
    "lineNumber": 122,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Balance of user."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "Number of pinakion to buy."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Balance of user."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "src/contracts/abstractions/MultipleArbitrable.js",
    "content": "import AbstractContract from '../AbstractContract'\n\n/**\n * Arbitrable Abstract Contarct API. This wraps an arbitrable contract. It provides\n * interaction with both the off chain store as well as the arbitrable instance. All\n * arbitrable methods from the supplied contract implementation can be called from this\n * object.\n */\nclass ArbitrableContract extends AbstractContract {\n  /**\n   * Submit evidence. FIXME should we determine the hash for the user?\n   * @param {string} account - ETH address of user.\n   * @param {string} arbitrableTransactionId - Id of the arbitrable transaction.\n   * @param {string} name - Name of evidence.\n   * @param {string} description - Description of evidence.\n   * @param {string} url - A link to an evidence using its URI.\n   * @param {string} hash - A hash of the evidence at the URI. No hash if content is dynamic\n   * @returns {string} - txHash Hash transaction.\n   */\n  submitEvidence = async (\n    account,\n    arbitrableTransactionId,\n    name,\n    description,\n    url,\n    hash\n  ) => {\n    const contractAddress = this._contractImplementation.contractAddress\n\n    // get the index of the new evidence\n    const evidenceIndex = await this._StoreProvider.addEvidenceContract(\n      contractAddress,\n      arbitrableTransactionId,\n      account,\n      name,\n      description,\n      url,\n      hash\n    )\n\n    // construct the unique URI\n    const evidenceUri = this._StoreProvider.getEvidenceUri(\n      account,\n      contractAddress,\n      arbitrableTransactionId,\n      evidenceIndex\n    )\n\n    const txHash = await this._contractImplementation.submitEvidence(\n      account,\n      arbitrableTransactionId,\n      evidenceUri\n    )\n\n    return txHash\n  }\n}\n\nexport default ArbitrableContract\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/abstractions/MultipleArbitrable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "class",
    "name": "ArbitrableContract",
    "memberof": "src/contracts/abstractions/MultipleArbitrable.js",
    "static": true,
    "longname": "src/contracts/abstractions/MultipleArbitrable.js~ArbitrableContract",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/abstractions/MultipleArbitrable.js",
    "importStyle": "ArbitrableContract",
    "description": "Arbitrable Abstract Contarct API. This wraps an arbitrable contract. It provides\ninteraction with both the off chain store as well as the arbitrable instance. All\narbitrable methods from the supplied contract implementation can be called from this\nobject.",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "src/contracts/AbstractContract.js~AbstractContract"
    ]
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "submitEvidence",
    "memberof": "src/contracts/abstractions/MultipleArbitrable.js~ArbitrableContract",
    "static": false,
    "longname": "src/contracts/abstractions/MultipleArbitrable.js~ArbitrableContract#submitEvidence",
    "access": "public",
    "description": "Submit evidence. FIXME should we determine the hash for the user?",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - txHash Hash transaction."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "Id of the arbitrable transaction."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "Description of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to an evidence using its URI."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "A hash of the evidence at the URI. No hash if content is dynamic"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "txHash Hash transaction."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "file",
    "name": "src/contracts/abstractions/index.js",
    "content": "import Arbitrator from './Arbitrator'\nimport Arbitrable from './Arbitrable'\n\nexport { Arbitrator, Arbitrable }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/abstractions/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 100,
    "kind": "file",
    "name": "src/contracts/implementations/PNK/MiniMePinakion.js",
    "content": "import PinakionPOCArtifact from 'kleros-interaction/build/contracts/MiniMeTokenERC20'\nimport _ from 'lodash'\n\nimport * as errorConstants from '../../../constants/error'\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\nimport isRequired from '../../../utils/isRequired'\n\n/**\n * Provides interaction with a PinakionPOC contract deployed on the blockchain.\n */\nclass MiniMePinakion extends ContractImplementation {\n  /**\n   * Constructor PinakionPOC.\n   * @param {object} web3Provider - web3 instance.\n   * @param {string} contractAddress - of the contract (optionnal).\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, PinakionPOCArtifact, contractAddress)\n  }\n\n  /**\n   * Deploy a new instance of PinakionPOC.\n   * @param {string} account - account of user\n   * @param {object} web3Provider - web3 provider object\n   * @param {string} tokenFactoryAddress - The address of the MiniMeTokenFactory contract that will create the Clone token contracts\n   * @param {string} parentTokenAddress - Address of the parent token, set to 0x0 if it is a new token\n   * @param {number} parentSnapshotBlock - Block of the parent token that will determine the initial distribution of the clone token, set to 0 if it is a new token\n   * @param {string} tokenName - Name of the token.\n   * @param {number} decimalUnits - Number of decimal units token is divisible by.\n   * @param {string} tokenSymbol - Abreviated symbol to represent the token.\n   * @param {bool} transfersEnabled - If users can transfer tokens.\n   * @returns {object} - 'truffle-contract' Object | err The contract object or error deploy.\n   */\n  static deploy = async (\n    account = isRequired('account'),\n    web3Provider = isRequired('web3Provider'),\n    tokenFactoryAddress = isRequired('tokenFactoryAddress'),\n    parentTokenAddress = '0x0',\n    parentSnapshotBlock = 0,\n    tokenName = 'Pinakion',\n    decimalUnits = 18,\n    tokenSymbol = 'PNK',\n    transfersEnabled = true\n  ) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      0, // value\n      PinakionPOCArtifact,\n      web3Provider,\n      tokenFactoryAddress, // args\n      parentTokenAddress,\n      parentSnapshotBlock,\n      tokenName,\n      decimalUnits,\n      tokenSymbol,\n      transfersEnabled\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Transfer ownership of the PNK contract to the kleros POC contract.\n   * @param {string} newControllerAddress - Address of the new controller.\n   * @param {string} controllerAccount - Address of the current controller. (They must sign the tx)\n   * @returns {object} - The result transaction object.\n   */\n  changeController = async (newControllerAddress, controllerAccount) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.changeController(newControllerAddress, {\n        from: controllerAccount\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_TRANSFER_OWNERSHIP)\n    }\n  }\n\n  /**\n   * Approve the arbitrator contract to transfer PNK to the contract and call the arbitrators\n   * receiveApproval()\n   * @param {string} arbitratorAddress - The address of the arbitrator contract.\n   * @param {number} amount - The amount of PNK to transfer in wei.\n   * @param {string} account - The users account.\n   * @returns {bool} If the transfer succeeded or not\n   */\n  approveAndCall = async (arbitratorAddress, amount, account) => {\n    await this.loadContract()\n\n    return this.contractInstance.approveAndCall(\n      arbitratorAddress,\n      amount,\n      '0x0',\n      {\n        from: account\n      }\n    )\n  }\n\n  /**\n   * Get the token balance for an account\n   * @param {string} account - The users account.\n   * @returns {number} the amount of tokens.\n   */\n  getTokenBalance = async account => {\n    await this.loadContract()\n\n    return this.contractInstance.balanceOf(account)\n  }\n\n  /**\n   * Fetch the controller of the contract.\n   * @returns {string} The ETH address of the controller.\n   */\n  getController = async () => {\n    await this.loadContract()\n\n    return this.contractInstance.controller()\n  }\n}\n\nexport default MiniMePinakion\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/PNK/MiniMePinakion.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 101,
    "kind": "class",
    "name": "MiniMePinakion",
    "memberof": "src/contracts/implementations/PNK/MiniMePinakion.js",
    "static": true,
    "longname": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/PNK/MiniMePinakion.js",
    "importStyle": "MiniMePinakion",
    "description": "Provides interaction with a PinakionPOC contract deployed on the blockchain.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 102,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion#constructor",
    "access": "public",
    "description": "Constructor PinakionPOC.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract (optionnal)."
      }
    ]
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion",
    "static": true,
    "longname": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion.deploy",
    "access": "public",
    "description": "Deploy a new instance of PinakionPOC.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - 'truffle-contract' Object | err The contract object or error deploy."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "account of user"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tokenFactoryAddress",
        "description": "The address of the MiniMeTokenFactory contract that will create the Clone token contracts"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "parentTokenAddress",
        "description": "Address of the parent token, set to 0x0 if it is a new token"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "parentSnapshotBlock",
        "description": "Block of the parent token that will determine the initial distribution of the clone token, set to 0 if it is a new token"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tokenName",
        "description": "Name of the token."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "decimalUnits",
        "description": "Number of decimal units token is divisible by."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tokenSymbol",
        "description": "Abreviated symbol to represent the token."
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "transfersEnabled",
        "description": "If users can transfer tokens."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "'truffle-contract' Object | err The contract object or error deploy."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "changeController",
    "memberof": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion",
    "static": false,
    "longname": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion#changeController",
    "access": "public",
    "description": "Transfer ownership of the PNK contract to the kleros POC contract.",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "newControllerAddress",
        "description": "Address of the new controller."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "controllerAccount",
        "description": "Address of the current controller. (They must sign the tx)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "approveAndCall",
    "memberof": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion",
    "static": false,
    "longname": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion#approveAndCall",
    "access": "public",
    "description": "Approve the arbitrator contract to transfer PNK to the contract and call the arbitrators\nreceiveApproval()",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{bool} If the transfer succeeded or not"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "The amount of PNK to transfer in wei."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The users account."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": "If the transfer succeeded or not"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "getTokenBalance",
    "memberof": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion",
    "static": false,
    "longname": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion#getTokenBalance",
    "access": "public",
    "description": "Get the token balance for an account",
    "lineNumber": 108,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} the amount of tokens."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The users account."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the amount of tokens."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "getController",
    "memberof": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion",
    "static": false,
    "longname": "src/contracts/implementations/PNK/MiniMePinakion.js~MiniMePinakion#getController",
    "access": "public",
    "description": "Fetch the controller of the contract.",
    "lineNumber": 118,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The ETH address of the controller."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The ETH address of the controller."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "file",
    "name": "src/contracts/implementations/PNK/PinakionPOC.js",
    "content": "import PinakionPOCArtifact from 'kleros/build/contracts/PinakionPOC' // FIXME: mock\nimport _ from 'lodash'\n\nimport * as ethConstants from '../../../constants/eth'\nimport * as errorConstants from '../../../constants/error'\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\n/**\n * Provides interaction with a PinakionPOC contract deployed on the blockchain.\n */\nclass PinakionPOC extends ContractImplementation {\n  /**\n   * Constructor PinakionPOC.\n   * @param {object} web3Provider - web3 instance.\n   * @param {string} contractAddress - of the contract (optionnal).\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, PinakionPOCArtifact, contractAddress)\n  }\n\n  /**\n   * Deploy a new instance of PinakionPOC.\n   * @param {string} account - account of user\n   * @param {object} web3Provider - web3 provider object\n   * @returns {object} - 'truffle-contract' Object | err The contract object or error deploy.\n   */\n  static deploy = async (account, web3Provider) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      ethConstants.TRANSACTION.VALUE,\n      PinakionPOCArtifact,\n      web3Provider\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Change the kleros contract variable in instance of PinakionPOC.\n   * @param {string} klerosAddress - Address of Kleros POC contract.\n   * @param {string} account - Address of user.\n   * @returns {object} - The result transaction object.\n   */\n  setKleros = async (klerosAddress, account) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.setKleros(klerosAddress, {\n        from: account\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_SET_KLEROS)\n    }\n  }\n\n  /**\n   * Transfer ownership of the PNK contract to the kleros POC contract.\n   * @param {string} klerosAddress - Address of Kleros POC contract.\n   * @param {string} account - Address of user.\n   * @returns {object} - The result transaction object.\n   */\n  transferOwnership = async (klerosAddress, account) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.transferOwnership(klerosAddress, {\n        from: account\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_TRANSFER_OWNERSHIP)\n    }\n  }\n\n  /**\n   * Get data from PNK contract.\n   * @returns {object} - Data from PNK contract.\n   */\n  getData = async () => {\n    await this.loadContract()\n    const [owner, kleros] = await Promise.all([\n      this.contractInstance.owner(),\n      this.contractInstance.kleros()\n    ])\n\n    return {\n      owner,\n      kleros\n    }\n  }\n}\n\nexport default PinakionPOC\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/PNK/PinakionPOC.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 109,
    "kind": "class",
    "name": "PinakionPOC",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js",
    "static": true,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/PNK/PinakionPOC.js",
    "importStyle": "PinakionPOC",
    "description": "Provides interaction with a PinakionPOC contract deployed on the blockchain.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 110,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#constructor",
    "access": "public",
    "description": "Constructor PinakionPOC.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract (optionnal)."
      }
    ]
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": true,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC.deploy",
    "access": "public",
    "description": "Deploy a new instance of PinakionPOC.",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - 'truffle-contract' Object | err The contract object or error deploy."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "account of user"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "'truffle-contract' Object | err The contract object or error deploy."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "setKleros",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#setKleros",
    "access": "public",
    "description": "Change the kleros contract variable in instance of PinakionPOC.",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "klerosAddress",
        "description": "Address of Kleros POC contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "transferOwnership",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#transferOwnership",
    "access": "public",
    "description": "Transfer ownership of the PNK contract to the kleros POC contract.",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "klerosAddress",
        "description": "Address of Kleros POC contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC",
    "static": false,
    "longname": "src/contracts/implementations/PNK/PinakionPOC.js~PinakionPOC#getData",
    "access": "public",
    "description": "Get data from PNK contract.",
    "lineNumber": 81,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Data from PNK contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Data from PNK contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "file",
    "name": "src/contracts/implementations/PNK/TokenFactory.js",
    "content": "import {\n  MiniMeTokenFactoryAbi,\n  MiniMeTokenFactoryByteCode\n} from 'minimetoken/build/MiniMeToken.sol'\nimport _ from 'lodash'\n\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\n/**\n * Provides interaction with a PinakionPOC contract deployed on the blockchain.\n */\nclass TokenFactory extends ContractImplementation {\n  /**\n   * Constructor PinakionPOC.\n   * @param {object} web3Provider - web3 instance.\n   * @param {string} contractAddress - of the contract (optionnal).\n   */\n  constructor(web3Provider, contractAddress) {\n    const artifact = {\n      abi: MiniMeTokenFactoryAbi,\n      bytecode: MiniMeTokenFactoryByteCode\n    }\n    super(web3Provider, artifact, contractAddress)\n  }\n\n  /**\n   * Deploy a new instance of PinakionPOC.\n   * @param {string} account - account of user\n   * @param {object} web3Provider - web3 provider object\n   * @returns {object} - 'truffle-contract' Object | err The contract object or error deploy.\n   */\n  static deploy = async (account, web3Provider) => {\n    const artifact = {\n      abi: MiniMeTokenFactoryAbi,\n      bytecode: MiniMeTokenFactoryByteCode\n    }\n\n    const contractDeployed = await deployContractAsync(\n      account, // account\n      0, // value\n      artifact, // artifact\n      web3Provider // web3\n    )\n\n    return contractDeployed\n  }\n}\n\nexport default TokenFactory\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/PNK/TokenFactory.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 116,
    "kind": "class",
    "name": "TokenFactory",
    "memberof": "src/contracts/implementations/PNK/TokenFactory.js",
    "static": true,
    "longname": "src/contracts/implementations/PNK/TokenFactory.js~TokenFactory",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/PNK/TokenFactory.js",
    "importStyle": "TokenFactory",
    "description": "Provides interaction with a PinakionPOC contract deployed on the blockchain.",
    "lineNumber": 13,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 117,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/PNK/TokenFactory.js~TokenFactory",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/PNK/TokenFactory.js~TokenFactory#constructor",
    "access": "public",
    "description": "Constructor PinakionPOC.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract (optionnal)."
      }
    ]
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/PNK/TokenFactory.js~TokenFactory",
    "static": true,
    "longname": "src/contracts/implementations/PNK/TokenFactory.js~TokenFactory.deploy",
    "access": "public",
    "description": "Deploy a new instance of PinakionPOC.",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - 'truffle-contract' Object | err The contract object or error deploy."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "account of user"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "'truffle-contract' Object | err The contract object or error deploy."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "file",
    "name": "src/contracts/implementations/PNK/index.js",
    "content": "import PinakionPOC from './PinakionPOC'\nimport MiniMePinakion from './MiniMePinakion'\nimport TokenFactory from './TokenFactory'\n\nexport { PinakionPOC, MiniMePinakion, TokenFactory }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/PNK/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 120,
    "kind": "file",
    "name": "src/contracts/implementations/RNG/BlockHashRNG.js",
    "content": "import BlockHashRNGArtifact from 'kleros-interaction/build/contracts/BlockHashRNGFallback'\nimport _ from 'lodash'\n\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\n/**\n * Provides interaction with an instance of BlockHashRNG.\n */\nclass BlockHashRNG extends ContractImplementation {\n  /**\n   * Constructor BlockHashRNG.\n   * @param {object} web3Provider - instance\n   * @param {string} contractAddress - of the contract (optionnal)\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, BlockHashRNGArtifact, contractAddress)\n  }\n\n  /**\n   * BlockHashRNG deploy.\n   * @param {string} account - users account\n   * @param {object} web3Provider - web3 provider object\n   * @returns {object} - truffle-contract Object | err The contract object or error deploy\n   */\n  static deploy = async (account, web3Provider) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      0,\n      BlockHashRNGArtifact,\n      web3Provider\n    )\n\n    return contractDeployed\n  }\n}\n\nexport default BlockHashRNG\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/RNG/BlockHashRNG.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 121,
    "kind": "class",
    "name": "BlockHashRNG",
    "memberof": "src/contracts/implementations/RNG/BlockHashRNG.js",
    "static": true,
    "longname": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/RNG/BlockHashRNG.js",
    "importStyle": "BlockHashRNG",
    "description": "Provides interaction with an instance of BlockHashRNG.",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 122,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG#constructor",
    "access": "public",
    "description": "Constructor BlockHashRNG.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract (optionnal)"
      }
    ]
  },
  {
    "__docId__": 123,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG",
    "static": true,
    "longname": "src/contracts/implementations/RNG/BlockHashRNG.js~BlockHashRNG.deploy",
    "access": "public",
    "description": "BlockHashRNG deploy.",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - truffle-contract Object | err The contract object or error deploy"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "users account"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The contract object or error deploy"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "file",
    "name": "src/contracts/implementations/RNG/index.js",
    "content": "import BlockHashRNG from './BlockHashRNG'\n\nexport { BlockHashRNG }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/RNG/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 125,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrable/Arbitrable.js",
    "content": "import _ from 'lodash'\n\nimport ContractImplementation from '../../ContractImplementation'\nimport EventListener from '../../../utils/EventListener'\nimport httpRequest from '../../../utils/httpRequest'\n\n/**\n * Provides interaction with standard Arbitrable contracts\n */\nclass Arbitrable extends ContractImplementation {\n  /**\n   * Constructor ArbitrableTransaction.\n   * @param {object} web3Provider instance.\n   * @param {object} contractArtifact The abi JSON of the arbitrable contract.\n   * @param {string} contractAddress of the contract.\n   */\n  constructor(web3Provider, contractArtifact, contractAddress) {\n    super(web3Provider, contractArtifact, contractAddress)\n\n    this.metaEvidenceCache = {}\n  }\n\n  /**\n   * Get the meta evidence for the contract. Arbitrable Transaction can only have\n   * one meta-evidence that is submitted on contract creation. Look up meta-evidence event\n   * and make an http request to the resource.\n   * @returns {object} The metaEvidence object\n   */\n  getMetaEvidence = async (metaEvidenceID = 0) => {\n    if (this.metaEvidenceCache[metaEvidenceID])\n      return this.metaEvidenceCache[metaEvidenceID]\n\n    const metaEvidenceLog = await EventListener.getEventLogs(\n      this,\n      'MetaEvidence',\n      0,\n      'latest',\n      { _metaEvidenceID: metaEvidenceID }\n    )\n\n    if (!metaEvidenceLog[0]) return {} // NOTE better to throw errors for missing meta-evidence?\n\n    const metaEvidenceUri = metaEvidenceLog[0].args._evidence\n    // FIXME caching issue need a query param to fetch from AWS\n    const metaEvidenceResponse = await httpRequest('GET', metaEvidenceUri)\n\n    if (metaEvidenceResponse.status >= 400)\n      throw new Error(`Unable to fetch meta-evidence at ${metaEvidenceUri}`)\n\n    this.metaEvidenceCache[metaEvidenceID] =\n      metaEvidenceResponse.body || metaEvidenceResponse\n    return metaEvidenceResponse.body || metaEvidenceResponse\n  }\n\n  /**\n   * Get the evidence submitted in a dispute.\n   * @returns {object[]} An array of evidence objects.\n   */\n  getEvidence = async (arbitratorAddress, disputeID = 0) => {\n    const evidenceLogs = await EventListener.getEventLogs(\n      this,\n      'Evidence',\n      0,\n      'latest',\n      { _disputeID: disputeID, _arbitrator: arbitratorAddress }\n    )\n\n    // TODO verify hash and data are valid if hash exists\n    return Promise.all(\n      evidenceLogs.map(async evidenceLog => {\n        const evidenceURI = evidenceLog.args._evidence\n        const evidence = await httpRequest('GET', evidenceURI)\n        const submittedAt = (await this._Web3Wrapper.getBlock(\n          evidenceLog.blockNumber\n        )).timestamp\n        return {\n          ...evidence.body,\n          ...{ submittedBy: evidenceLog.args._party, submittedAt }\n        }\n      })\n    )\n  }\n\n  /**\n   * Fetch all standard contract data.\n   */\n  getContractData = async () => {\n    await this.loadContract()\n\n    const [metaEvidence] = await Promise.all([this.getMetaEvidence()])\n\n    return {\n      metaEvidence\n    }\n  }\n}\n\nexport default Arbitrable\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrable/Arbitrable.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 126,
    "kind": "class",
    "name": "Arbitrable",
    "memberof": "src/contracts/implementations/arbitrable/Arbitrable.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrable/Arbitrable.js",
    "importStyle": "Arbitrable",
    "description": "Provides interaction with standard Arbitrable contracts",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 127,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable#constructor",
    "access": "public",
    "description": "Constructor ArbitrableTransaction.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "instance."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contractArtifact",
        "description": "The abi JSON of the arbitrable contract."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract."
      }
    ]
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "metaEvidenceCache",
    "memberof": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable#metaEvidenceCache",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "getMetaEvidence",
    "memberof": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable#getMetaEvidence",
    "access": "public",
    "description": "Get the meta evidence for the contract. Arbitrable Transaction can only have\none meta-evidence that is submitted on contract creation. Look up meta-evidence event\nand make an http request to the resource.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The metaEvidence object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The metaEvidence object"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "getEvidence",
    "memberof": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable#getEvidence",
    "access": "public",
    "description": "Get the evidence submitted in a dispute.",
    "lineNumber": 59,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} An array of evidence objects."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "An array of evidence objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "getContractData",
    "memberof": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable#getContractData",
    "access": "public",
    "description": "Fetch all standard contract data.",
    "lineNumber": 87,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrable/ArbitrablePermissionList.js",
    "content": "import ArbitrablePermissionListArtifact from 'kleros-interaction/build/contracts/ArbitrablePermissionList'\n\nimport Arbitrable from './Arbitrable'\n\n/**\n * Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.\n */\nclass ArbitrablePermissionList extends Arbitrable {\n  /**\n   * Constructor ArbitrableTransaction.\n   * @param {object} web3Provider instance\n   * @param {string} contractAddress of the contract\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, ArbitrablePermissionListArtifact, contractAddress)\n  }\n\n  /**\n   * Fetch an item hash by disputeID\n   * @param {number} disputeID The index of the dispute.\n   * @returns {string} The item hash.\n   */\n  getItemByDisputeId = async disputeID => {\n    await this.loadContract()\n\n    return this.contractInstance.disputeIDToItem(disputeID)\n  }\n}\n\nexport default ArbitrablePermissionList\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrable/ArbitrablePermissionList.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 133,
    "kind": "class",
    "name": "ArbitrablePermissionList",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrablePermissionList.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/ArbitrablePermissionList.js~ArbitrablePermissionList",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrable/ArbitrablePermissionList.js",
    "importStyle": "ArbitrablePermissionList",
    "description": "Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable"
    ]
  },
  {
    "__docId__": 134,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrablePermissionList.js~ArbitrablePermissionList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrablePermissionList.js~ArbitrablePermissionList#constructor",
    "access": "public",
    "description": "Constructor ArbitrableTransaction.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract"
      }
    ]
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "getItemByDisputeId",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrablePermissionList.js~ArbitrablePermissionList",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrablePermissionList.js~ArbitrablePermissionList#getItemByDisputeId",
    "access": "public",
    "description": "Fetch an item hash by disputeID",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The item hash."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The item hash."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "content": "import arbitrableTransactionArtifact from 'kleros-interaction/build/contracts/ArbitrableTransaction'\nimport _ from 'lodash'\n\nimport * as ethConstants from '../../../constants/eth'\nimport * as contractConstants from '../../../constants/contract'\nimport * as errorConstants from '../../../constants/error'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\nimport Arbitrable from './Arbitrable'\n\n/**\n * Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.\n */\nclass ArbitrableTransaction extends Arbitrable {\n  /**\n   * Constructor ArbitrableTransaction.\n   * @param {object} web3Provider instance\n   * @param {string} contractAddress of the contract\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, arbitrableTransactionArtifact, contractAddress)\n  }\n\n  /**\n   * Deploy ArbitrableTransaction.\n   * @param {object} account Ethereum account\n   * @param {number} value funds to be placed in contract\n   * @param {string} arbitratorAddress The address of the arbitrator contract\n   * @param {number} timeout Time after which a party automatically loose a dispute.\n   * @param {string} partyB The recipient of the transaction.\n   * @param {bytes} arbitratorExtraData Extra data for the arbitrator. (default empty string)\n   * @param {string} metaEvidenceUri The uri for the metaEvidence\n   * @param {object} web3Provider web3 provider object\n   * @returns {object} truffle-contract Object | err The deployed contract or an error\n   */\n  static deploy = async (\n    account,\n    value = ethConstants.TRANSACTION.VALUE,\n    arbitratorAddress,\n    timeout,\n    partyB,\n    arbitratorExtraData = '',\n    metaEvidenceUri,\n    web3Provider\n  ) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      value,\n      arbitrableTransactionArtifact,\n      web3Provider,\n      arbitratorAddress,\n      timeout,\n      partyB,\n      arbitratorExtraData,\n      metaEvidenceUri\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Pay the party B. To be called when the good is delivered or the service rendered.\n   * @param {string} account - Ethereum address.\n   * @returns {object} - The result transaction object.\n   */\n  pay = async account => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.pay({\n        from: account,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_SELLER)\n    }\n  }\n\n  /**\n   * Pay the arbitration fee to raise a dispute. To be called by the party A.\n   * @param {string} account - Ethereum address.\n   * @param {number} arbitrationCost - Arbitration fee in wei.\n   * @returns {object} - The result transaction object.\n   */\n  payArbitrationFeeByPartyA = async (account, arbitrationCost) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.payArbitrationFeeByPartyA({\n        from: account,\n        value: arbitrationCost\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_ARBITRATION_FEE)\n    }\n  }\n\n  /**\n   * Pay the arbitration fee to raise a dispute. To be called by the party B.\n   * @param {string} account Ethereum address.\n   * @param {number} arbitrationCost Amount to pay the arbitrator.\n   * @returns {object} - The result transaction object.\n   */\n  payArbitrationFeeByPartyB = async (account, arbitrationCost) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.payArbitrationFeeByPartyB({\n        from: account,\n        value: arbitrationCost,\n        gas: process.env.GAS || undefined\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_ARBITRATION_FEE)\n    }\n  }\n\n  /**\n   * Submit evidence.\n   * @param {string} account ETH address of user.\n   * @param {string} url A link to an evidence using its URI.\n   * @returns {string} txHash Hash transaction.\n   */\n  submitEvidence = async (account, url) => {\n    await this.loadContract()\n\n    const txHashObj = await this.contractInstance.submitEvidence(url, {\n      from: account,\n      value: 0\n    })\n\n    return txHashObj.tx\n  }\n\n  /**\n   * Call by partyA if partyB is timeout\n   * @param {string} account ETH address of user\n   * @returns {object} The result transaction object.\n   */\n  callTimeOutPartyA = async account => {\n    await this.loadContract()\n\n    const status = (await this.contractInstance.status()).toNumber()\n    const timeout = (await this.contractInstance.timeout()).toNumber()\n    const lastInteraction = (await this.contractInstance.lastInteraction()).toNumber()\n\n    if (status !== contractConstants.STATUS.WAITING_PARTY_B) {\n      throw new Error(errorConstants.CONTRACT_IS_NOT_WAITING_ON_OTHER_PARTY)\n    } else if (Date.now() >= lastInteraction + timeout) {\n      throw new Error(errorConstants.TIMEOUT_NOT_REACHED)\n    }\n\n    try {\n      return this.contractInstance.timeOutByPartyA({\n        from: account,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_CALL_TIMEOUT)\n    }\n  }\n\n  /**\n   * Call by partyB if partyA is timeout.\n   * @param {string} account - ETH address of user.\n   * @returns {object} The result transaction object.\n   */\n  callTimeOutPartyB = async account => {\n    await this.loadContract()\n\n    const status = await this.contractInstance.status()\n    const timeout = await this.contractInstance.timeout()\n    const lastInteraction = await this.contractInstance.lastInteraction()\n\n    if (status !== contractConstants.STATUS.WAITING_PARTY_A) {\n      throw new Error(errorConstants.CONTRACT_IS_NOT_WAITING_ON_OTHER_PARTY)\n    } else if (Date.now() >= lastInteraction + timeout) {\n      throw new Error(errorConstants.TIMEOUT_NOT_REACHED)\n    }\n\n    try {\n      return this.contractInstance.timeOutByPartyB({\n        from: account,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_CALL_TIMEOUT)\n    }\n  }\n\n  /**\n   * Appeal an appealable ruling.\n   * @param {string} account Ethereum account (default account[0]).\n   * @param {number} appealCost Fee for the appeal\n   * @param {bytes} extraData for the arbitrator appeal procedure.\n   * @returns {object} - The result transaction object.\n   */\n  appeal = async (account, appealCost, extraData = 0x0) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.appeal(extraData, {\n        from: account,\n        value: appealCost\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_RAISE_AN_APPEAL)\n    }\n  }\n\n  /**\n   * Fetch the parties involved in the arbitrable transaction contract.\n   * @returns {object} returns a mapping of partyA and partyB to ETH addresses.\n   */\n  getParties = async () => {\n    await this.loadContract()\n\n    const [partyA, partyB] = await Promise.all([\n      this.contractInstance.partyA(),\n      this.contractInstance.partyB()\n    ])\n\n    return {\n      partyA,\n      partyB\n    }\n  }\n\n  /**\n   * Data of the contract\n   * @returns {object} Object Data of the contract.\n   */\n  getData = async () => {\n    await this.loadContract()\n\n    const [\n      arbitrator,\n      extraData,\n      timeout,\n      partyA,\n      partyB,\n      status,\n      arbitratorExtraData,\n      disputeID,\n      partyAFee,\n      partyBFee,\n      lastInteraction,\n      amount,\n      evidence,\n      metaEvidence\n    ] = await Promise.all([\n      this.contractInstance.arbitrator(),\n      this.contractInstance.arbitratorExtraData(),\n      //  this.contractInstance.hashContract(),\n      this.contractInstance.timeout(),\n      this.contractInstance.partyA(),\n      this.contractInstance.partyB(),\n      this.contractInstance.status(),\n      this.contractInstance.arbitratorExtraData(),\n      this.contractInstance.disputeID(),\n      this.contractInstance.partyAFee(),\n      this.contractInstance.partyBFee(),\n      this.contractInstance.lastInteraction(),\n      this.contractInstance.amount(),\n      this.getEvidence(),\n      this.getMetaEvidence()\n    ])\n\n    return {\n      address: this.getContractAddress(),\n      arbitrator,\n      extraData,\n      timeout: timeout.toNumber(),\n      partyA,\n      partyB,\n      status: status.toNumber(),\n      arbitratorExtraData,\n      disputeID: disputeID.toNumber(),\n      partyAFee,\n      partyBFee,\n      lastInteraction: lastInteraction.toNumber(),\n      amount: amount.toNumber(),\n      evidence,\n      metaEvidence\n    }\n  }\n}\n\nexport default ArbitrableTransaction\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 137,
    "kind": "class",
    "name": "ArbitrableTransaction",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrable/ArbitrableTransaction.js",
    "importStyle": "ArbitrableTransaction",
    "description": "Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable"
    ]
  },
  {
    "__docId__": 138,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#constructor",
    "access": "public",
    "description": "Constructor ArbitrableTransaction.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract"
      }
    ]
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction.deploy",
    "access": "public",
    "description": "Deploy ArbitrableTransaction.",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} truffle-contract Object | err The deployed contract or an error"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "funds to be placed in contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Time after which a party automatically loose a dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "partyB",
        "description": "The recipient of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorExtraData",
        "description": "Extra data for the arbitrator. (default empty string)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "metaEvidenceUri",
        "description": "The uri for the metaEvidence"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The deployed contract or an error"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "pay",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#pay",
    "access": "public",
    "description": "Pay the party B. To be called when the good is delivered or the service rendered.",
    "lineNumber": 66,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum address."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "payArbitrationFeeByPartyA",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#payArbitrationFeeByPartyA",
    "access": "public",
    "description": "Pay the arbitration fee to raise a dispute. To be called by the party A.",
    "lineNumber": 86,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum address."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrationCost",
        "description": "Arbitration fee in wei."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "payArbitrationFeeByPartyB",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#payArbitrationFeeByPartyB",
    "access": "public",
    "description": "Pay the arbitration fee to raise a dispute. To be called by the party B.",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum address."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrationCost",
        "description": "Amount to pay the arbitrator."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "submitEvidence",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#submitEvidence",
    "access": "public",
    "description": "Submit evidence.",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} txHash Hash transaction."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to an evidence using its URI."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "txHash Hash transaction."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "callTimeOutPartyA",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#callTimeOutPartyA",
    "access": "public",
    "description": "Call by partyA if partyB is timeout",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "callTimeOutPartyB",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#callTimeOutPartyB",
    "access": "public",
    "description": "Call by partyB if partyA is timeout.",
    "lineNumber": 172,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "appeal",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#appeal",
    "access": "public",
    "description": "Appeal an appealable ruling.",
    "lineNumber": 203,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account (default account[0])."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appealCost",
        "description": "Fee for the appeal"
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "extraData",
        "description": "for the arbitrator appeal procedure."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "member",
    "name": "getParties",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#getParties",
    "access": "public",
    "description": "Fetch the parties involved in the arbitrable transaction contract.",
    "lineNumber": 221,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} returns a mapping of partyA and partyB to ETH addresses."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "returns a mapping of partyA and partyB to ETH addresses."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/ArbitrableTransaction.js~ArbitrableTransaction#getData",
    "access": "public",
    "description": "Data of the contract",
    "lineNumber": 239,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} Object Data of the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object Data of the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js",
    "content": "import multipleArbitrableTransactionArtifact from 'kleros-interaction/build/contracts/MultipleArbitrableTransaction'\nimport _ from 'lodash'\n\nimport * as contractConstants from '../../../constants/contract'\nimport * as errorConstants from '../../../constants/error'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\nimport Arbitrable from './Arbitrable'\n\n/**\n * Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.\n */\nclass MultipleArbitrableTransaction extends Arbitrable {\n  /**\n   * Constructor ArbitrableTransaction.\n   * @param {object} web3Provider instance\n   * @param {string} contractAddress of the contract\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, multipleArbitrableTransactionArtifact, contractAddress)\n\n    this.arbitrableTransactionId = null\n  }\n\n  /**\n   * Deploy MultipleArbitrableTransaction.\n   * @param {object} account Ethereum account\n   * @param {object} web3Provider web3 provider object\n   * @returns {object} truffle-contract Object | err The deployed contract or an error\n   */\n  static deploy = async (account, web3Provider) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      0,\n      multipleArbitrableTransactionArtifact,\n      web3Provider\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Create MultipleArbitrableTransaction.\n   * @param {object} account Ethereum account\n   * @param {string} arbitratorAddress The address of the arbitrator contract\n   * @param {object} seller Seller Ethereum account\n   * @param {number} value funds to be placed in contract\n   * @param {number} timeout Time (seconds) after which a party automatically loose a dispute. (default 3600)\n   * @param {bytes} arbitratorExtraData Extra data for the arbitrator. (default empty string)\n   * @param {string} metaEvidenceUri Uri meta-evidence. (default empty string)\n   * @returns {object} truffle-contract Object | err The deployed contract or an error\n   */\n  createArbitrableTransaction = async (\n    account,\n    arbitratorAddress,\n    seller,\n    value,\n    timeout = 3600,\n    arbitratorExtraData = 0x0,\n    metaEvidenceUri\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.createTransaction(\n        arbitratorAddress,\n        timeout,\n        seller,\n        arbitratorExtraData,\n        metaEvidenceUri,\n        {\n          from: account,\n          value: value,\n          gas: process.env.GAS || undefined\n        }\n      )\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_CREATE_TRANSACTION)\n    }\n  }\n\n  /**\n   * Pay the seller. To be called when the good is delivered or the service rendered.\n   * @param {string} account - Ethereum account.\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @param {amount} amount - Part or all of the amount of the good or the service.\n   * @returns {object} - The result transaction object.\n   */\n  pay = async (account, arbitrableTransactionId, amount) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.pay(arbitrableTransactionId, amount, {\n        from: account,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_SELLER)\n    }\n  }\n\n  /**\n   * Reimburse the seller. To be called when the good is not delivered or the service rendered.\n   * @param {string} account - Ethereum account.\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @param {amount} amount - Part or all of the amount of the good or the service.\n   * @returns {object} - The result transaction object.\n   */\n  reimburse = async (\n    account,\n    arbitrableTransactionId,\n    amount\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.reimburse(arbitrableTransactionId, amount, {\n        from: account,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_REIMBURSE_BUYER)\n    }\n  }\n\n  /**\n   * Pay the arbitration fee to raise a dispute. To be called by the buyer.\n   * @param {string} account - Ethereum account.\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @param {number} arbitrationCost - Arbitration cost.\n   * @returns {object} - The result transaction object.\n   */\n  payArbitrationFeeByBuyer = async (\n    account,\n    arbitrableTransactionId,\n    arbitrationCost\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.payArbitrationFeeByBuyer(\n        arbitrableTransactionId,\n        {\n          from: account,\n          value: arbitrationCost\n        }\n      )\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_ARBITRATION_FEE)\n    }\n  }\n\n  /**\n   * Pay the arbitration fee to raise a dispute. To be called by the seller.\n   * @param {string} account Ethereum account.\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @param {number} arbitrationCost - Arbitration cost.\n   * @returns {object} - The result transaction object.\n   */\n  payArbitrationFeeBySeller = async (\n    account,\n    arbitrableTransactionId,\n    arbitrationCost\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.payArbitrationFeeBySeller(\n        arbitrableTransactionId,\n        {\n          from: account,\n          value: arbitrationCost,\n          gas: process.env.GAS || undefined\n        }\n      )\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PAY_ARBITRATION_FEE)\n    }\n  }\n\n  /**\n   * Submit evidence.\n   * @param {string} account ETH address of user.\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @param {string} url A link to an evidence using its URI.\n   * @returns {string} txHash Hash transaction.\n   */\n  submitEvidence = async (\n    account,\n    arbitrableTransactionId,\n    url\n  ) => {\n    await this.loadContract()\n\n    const txHashObj = await this.contractInstance.submitEvidence(\n      arbitrableTransactionId,\n      url,\n      {\n        from: account,\n        value: 0\n      }\n    )\n\n    return txHashObj.tx\n  }\n\n  /**\n   * Call by buyer if seller is timeout\n   * @param {string} account ETH address of user\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @returns {object} The result transaction object.\n   */\n  callTimeOutBuyer = async (\n    account,\n    arbitrableTransactionId\n  ) => {\n    await this.loadContract()\n\n    const transactionArbitrableData = await this.getData(\n      arbitrableTransactionId\n    )\n\n    const status = transactionArbitrableData.status\n    const timeout = transactionArbitrableData.timeout\n    const lastInteraction = transactionArbitrableData.lastInteraction\n\n    if (status !== contractConstants.STATUS.WAITING_SELLER) {\n      throw new Error(errorConstants.CONTRACT_IS_NOT_WAITING_ON_OTHER_PARTY)\n    } else if (Math.trunc(Date.now() / 1000) <= lastInteraction + timeout) {\n      throw new Error(errorConstants.TIMEOUT_NOT_REACHED)\n    }\n\n    try {\n      return this.contractInstance.timeOutByBuyer(arbitrableTransactionId, {\n        from: account,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_CALL_TIMEOUT)\n    }\n  }\n\n  /**\n   * Call by seller if buyer is timeout.\n   * @param {string} account - ETH address of user.\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @param {string} contractAddress - ETH address of contract.\n   * @returns {object} The result transaction object.\n   */\n  callTimeOutSeller = async (\n    account,\n    arbitrableTransactionId\n  ) => {\n    await this.loadContract()\n\n    const status = await this.contractInstance.status()\n    const timeout = await this.contractInstance.timeout()\n    const lastInteraction = await this.contractInstance.lastInteraction()\n\n    if (status !== contractConstants.STATUS.WAITING_BUYER) {\n      throw new Error(errorConstants.CONTRACT_IS_NOT_WAITING_ON_OTHER_PARTY)\n    } else if (Date.now() >= lastInteraction + timeout) {\n      throw new Error(errorConstants.TIMEOUT_NOT_REACHED)\n    }\n\n    try {\n      return this.contractInstance.timeOutBySeller(arbitrableTransactionId, {\n        from: account,\n        value: 0\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_CALL_TIMEOUT)\n    }\n  }\n\n  /**\n   * Appeal an appealable ruling.\n   * @param {string} account Ethereum account.\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @param {bytes} extraData for the arbitrator appeal procedure.\n   * @param {number} appealCost Amount to pay the arbitrator. (default 0.35 ether).\n   * @returns {object} - The result transaction object.\n   */\n  appeal = async (\n    account,\n    arbitrableTransactionId,\n    extraData = 0x0,\n    appealCost = 0.3\n  ) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.appeal(arbitrableTransactionId, extraData, {\n        from: account,\n        value: appealCost\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_RAISE_AN_APPEAL)\n    }\n  }\n\n  /**\n   * Set the arbitrable transaction id\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @returns {object} Object Data of the contract.\n   */\n  setArbitrableTransactionId = arbitrableTransactionId =>\n    (this.arbitrableTransactionId = arbitrableTransactionId)\n\n  /**\n   * Data of the contract\n   * @param {number} arbitrableTransactionId - The index of the transaction.\n   * @returns {object} Object Data of the contract.\n   */\n  getData = async arbitrableTransactionId => {\n    await this.loadContract()\n\n    const arbitrableTransaction = await this.contractInstance.transactions(\n      arbitrableTransactionId\n    )\n\n    return {\n      seller: arbitrableTransaction[0],\n      buyer: arbitrableTransaction[1],\n      amount: arbitrableTransaction[2].toNumber(),\n      timeout: arbitrableTransaction[3].toNumber(),\n      disputeId: arbitrableTransaction[4].toNumber(),\n      arbitrator: arbitrableTransaction[5],\n      arbitratorExtraData: arbitrableTransaction[6],\n      sellerFee: this._Web3Wrapper.fromWei(arbitrableTransaction[7], 'ether'),\n      buyerFee: this._Web3Wrapper.fromWei(arbitrableTransaction[8], 'ether'),\n      lastInteraction: arbitrableTransaction[9].toNumber(),\n      status: arbitrableTransaction[10].toNumber(),\n      metaEvidence: await this.getMetaEvidence(arbitrableTransactionId),\n      evidence: await this.getEvidence(\n        arbitrableTransaction[5],\n        arbitrableTransaction[4].toNumber()\n      )\n    }\n  }\n}\n\nexport default MultipleArbitrableTransaction\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 150,
    "kind": "class",
    "name": "MultipleArbitrableTransaction",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js",
    "importStyle": "MultipleArbitrableTransaction",
    "description": "Provides interaction with an Arbitrable Transaction contract deployed on the blockchain.",
    "lineNumber": 13,
    "interface": false,
    "extends": [
      "src/contracts/implementations/arbitrable/Arbitrable.js~Arbitrable"
    ]
  },
  {
    "__docId__": 151,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#constructor",
    "access": "public",
    "description": "Constructor ArbitrableTransaction.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "of the contract"
      }
    ]
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "arbitrableTransactionId",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#arbitrableTransactionId",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": true,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction.deploy",
    "access": "public",
    "description": "Deploy MultipleArbitrableTransaction.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} truffle-contract Object | err The deployed contract or an error"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The deployed contract or an error"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "createArbitrableTransaction",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#createArbitrableTransaction",
    "access": "public",
    "description": "Create MultipleArbitrableTransaction.",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} truffle-contract Object | err The deployed contract or an error"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "seller",
        "description": "Seller Ethereum account"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "funds to be placed in contract"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "Time (seconds) after which a party automatically loose a dispute. (default 3600)"
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorExtraData",
        "description": "Extra data for the arbitrator. (default empty string)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "metaEvidenceUri",
        "description": "Uri meta-evidence. (default empty string)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The deployed contract or an error"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "pay",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#pay",
    "access": "public",
    "description": "Pay the seller. To be called when the good is delivered or the service rendered.",
    "lineNumber": 90,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "amount"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "Part or all of the amount of the good or the service."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "member",
    "name": "reimburse",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#reimburse",
    "access": "public",
    "description": "Reimburse the seller. To be called when the good is not delivered or the service rendered.",
    "lineNumber": 111,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "amount"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "Part or all of the amount of the good or the service."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "member",
    "name": "payArbitrationFeeByBuyer",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#payArbitrationFeeByBuyer",
    "access": "public",
    "description": "Pay the arbitration fee to raise a dispute. To be called by the buyer.",
    "lineNumber": 136,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrationCost",
        "description": "Arbitration cost."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "payArbitrationFeeBySeller",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#payArbitrationFeeBySeller",
    "access": "public",
    "description": "Pay the arbitration fee to raise a dispute. To be called by the seller.",
    "lineNumber": 164,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrationCost",
        "description": "Arbitration cost."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "submitEvidence",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#submitEvidence",
    "access": "public",
    "description": "Submit evidence.",
    "lineNumber": 193,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} txHash Hash transaction."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to an evidence using its URI."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "txHash Hash transaction."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "callTimeOutBuyer",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#callTimeOutBuyer",
    "access": "public",
    "description": "Call by buyer if seller is timeout",
    "lineNumber": 218,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "callTimeOutSeller",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#callTimeOutSeller",
    "access": "public",
    "description": "Call by seller if buyer is timeout.",
    "lineNumber": 256,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "ETH address of user."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "ETH address of contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "appeal",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#appeal",
    "access": "public",
    "description": "Appeal an appealable ruling.",
    "lineNumber": 291,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Ethereum account."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "extraData",
        "description": "for the arbitrator appeal procedure."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appealCost",
        "description": "Amount to pay the arbitrator. (default 0.35 ether)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "setArbitrableTransactionId",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#setArbitrableTransactionId",
    "access": "public",
    "description": "Set the arbitrable transaction id",
    "lineNumber": 315,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} Object Data of the contract."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object Data of the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction",
    "static": false,
    "longname": "src/contracts/implementations/arbitrable/MultipleArbitrableTransaction.js~MultipleArbitrableTransaction#getData",
    "access": "public",
    "description": "Data of the contract",
    "lineNumber": 323,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} Object Data of the contract."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionId",
        "description": "The index of the transaction."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object Data of the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrable/index.js",
    "content": "import ArbitrableTransaction from './ArbitrableTransaction'\nimport MultipleArbitrableTransaction from './MultipleArbitrableTransaction'\nimport ArbitrablePermissionList from './ArbitrablePermissionList'\n\nexport {\n  ArbitrableTransaction,\n  MultipleArbitrableTransaction,\n  ArbitrablePermissionList\n}\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrable/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 166,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrator/Kleros.js",
    "content": "import klerosArtifact from 'kleros/build/contracts/Kleros'\nimport _ from 'lodash'\n\nimport MiniMePinakion from '../PNK/MiniMePinakion'\nimport * as ethConstants from '../../../constants/eth'\nimport * as errorConstants from '../../../constants/error'\nimport * as arbitratorConstants from '../../../constants/arbitrator'\nimport ContractImplementation from '../../ContractImplementation'\nimport deployContractAsync from '../../../utils/deployContractAsync'\nimport EventListener from '../../../utils/EventListener'\n\n/**\n * Provides interaction with a Kleros contract on the blockchain.\n */\nclass Kleros extends ContractImplementation {\n  /**\n   * Create new Kleros Implementation.\n   * @param {object} web3Provider - web3 instance.\n   * @param {string} contractAddress - Address of the Kleros contract.\n   * @param {object} artifact - <optional> An alternate Kleros artifact can be\n   * passed for classes that inherit Kleros (such as KlerosPOC)\n   */\n  constructor(web3Provider, contractAddress, artifact = klerosArtifact) {\n    super(web3Provider, artifact, contractAddress)\n    this._disputeDeadlineCache = {}\n    this._appealCreationTimestampCache = {}\n    this._appealRuledAtTimestampCache = {}\n    this._openDisputesCache = {}\n  }\n\n  /**\n   * STATIC: Deploy a Kleros contract on the blockchain.\n   * @param {string} rngAddress address of random number generator contract\n   * @param {string} pnkAddress address of pinakion contract\n   * @param {number[]} timesPerPeriod array of 5 ints indicating the time limit for each period of contract\n   * @param {string} account address of user\n   * @param {number} value amout of eth to send to contract\n   * @param {object} web3Provider web3 provider object NOTE: NOT Kleros Web3Wrapper\n   * @returns {object} truffle-contract Object | err The contract object or error deploy\n   */\n  static deploy = async (\n    rngAddress,\n    pnkAddress,\n    timesPerPeriod = [300, 0, 300, 300, 300],\n    account,\n    value = ethConstants.TRANSACTION.VALUE,\n    web3Provider\n  ) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      value,\n      klerosArtifact,\n      web3Provider,\n      pnkAddress,\n      rngAddress,\n      timesPerPeriod\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Deposit PNK to the contract.\n   * @param {number} amount - The amount of PNK to deposit.\n   * @param {string} account - The address of the user.\n   * @returns {object} - Balance information including total PNK balance and activated tokens.\n   */\n  transferPNKToArbitrator = async (\n    amount,\n    account = this._Web3Wrapper.getAccount(0)\n  ) => {\n    await this.loadContract()\n\n    const pinakionContractAddress = await this.contractInstance.pinakion()\n    const pnkInstance = new MiniMePinakion(\n      this.getWeb3Provider(),\n      pinakionContractAddress\n    )\n\n    const deposited = await pnkInstance.approveAndCall(\n      this.contractAddress,\n      amount,\n      account\n    )\n    if (!deposited) throw new Error('Unable to deposit PNK')\n\n    return this.getPNKBalance(account)\n  }\n\n  /**\n   * Withdraw PNK from the contract.\n   * @param {number} amount - The BigNumber amount of PNK to deposit.\n   * @param {string} account - The address of the user.\n   * @returns {object} - Balance information including total PNK balance and activated tokens.\n   */\n  withdrawPNK = async (amount, account) => {\n    await this.loadContract()\n    await this.contractInstance.withdraw(amount, {\n      from: account\n    })\n\n    return this.getPNKBalance(account)\n  }\n\n  /**\n   * Get PNK Balances.\n   * @param {string} account - The address of the user.\n   * @returns {object} - Balance information including total PNK balance and activated tokens.\n   */\n  getPNKBalance = async account => {\n    await this.loadContract()\n\n    const pinakionContractAddress = await this.contractInstance.pinakion()\n    const pnkInstance = new MiniMePinakion(\n      this.getWeb3Provider(),\n      pinakionContractAddress\n    )\n\n    const contractBalance = await pnkInstance.getTokenBalance(account)\n\n    const juror = await this.contractInstance.jurors(account)\n    if (!juror)\n      throw new Error(\n        errorConstants.ACCOUNT_NOT_A_JUROR_FOR_CONTRACT(\n          account,\n          this.contractAddress\n        )\n      )\n\n    // Activated Tokens\n    const currentSession = await this.contractInstance.session()\n    let activatedTokens = this._Web3Wrapper.toBigNumber(0)\n    if (juror[2].toNumber() === currentSession.toNumber())\n      activatedTokens = juror[4].minus(juror[3])\n\n    return {\n      tokenBalance: juror[0],\n      activatedTokens,\n      lockedTokens: juror[1],\n      contractBalance\n    }\n  }\n\n  /**\n   * Activate Pinakion tokens to be eligible to be a juror.\n   * @param {string} amount - Amount in wei of tokens to activate.\n   * @param {string} account - Address of user.\n   * @returns {object} - PNK balance in wei.\n   */\n  activatePNK = async (\n    amount, // amount in wei\n    account\n  ) => {\n    await this.loadContract()\n\n    try {\n      await this.contractInstance.activateTokens(amount, {\n        from: account\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_ACTIVATE_PNK)\n    }\n\n    return this.getPNKBalance(account)\n  }\n\n  /**\n   * Fetch the cost of arbitration.\n   * @param {bytes} contractExtraData - extra data from arbitrable contract.\n   * @returns {number} - The cost of arbitration as a BigNumber.\n   */\n  getArbitrationCost = async contractExtraData => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.arbitrationCost(contractExtraData)\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_ARBITRATION_COST)\n    }\n  }\n\n  /**\n   * Fetch the cost of appeal.\n   * @param {number} disputeID - index of the dispute.\n   * @param {bytes} contractExtraData - extra data from arbitrable contract.\n   * @returns {number} - The cost of appeal as a BigNumber.\n   */\n  getAppealCost = async (disputeID, contractExtraData) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.appealCost(disputeID, contractExtraData)\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_APPEAL_COST)\n    }\n  }\n\n  /**\n   * Call contract to move on to the next period.\n   * @param {string} account - address of user.\n   * @returns {Promise} - resulting object.\n   */\n  passPeriod = async account => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.passPeriod.original({\n        from: account\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_PASS_PERIOD)\n    }\n  }\n\n  /**\n   * Submit votes. Note can only be called during Voting period (Period 2).\n   * @param {number} disputeID - index of the dispute.\n   * @param {number} ruling - int representing the jurors decision.\n   * @param {number[]} votes - int[] of drawn votes for dispute.\n   * @param {string} account - address of user.\n   * @returns {object} - The result transaction object.\n   */\n  submitVotes = async (disputeID, ruling, votes, account) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.voteRuling(disputeID, ruling, votes, {\n        from: account,\n        gas: process.env.GAS || undefined\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_SUBMIT_VOTES)\n    }\n  }\n\n  /**\n   * Appeal ruling on dispute.\n   * @param {number} disputeID - Index of the dispute.\n   * @param {string} extraData - Extra data.\n   * @param {string} account - Address of user.\n   * @returns {object} - The result transaction object.\n   */\n  appealRuling = async (disputeID, extraData, account) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.appeal(disputeID, extraData, {\n        from: account,\n        value: await this.contractInstance.appealCost(disputeID, extraData)\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_APPEAL)\n    }\n  }\n\n  /**\n   * Repartition juror tokens.\n   * @param {number} disputeID - index of the dispute.\n   * @param {string} account - address of user.\n   * @returns {object} - The result transaction object.\n   */\n  repartitionJurorTokens = async (disputeID, account) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.oneShotTokenRepartition(disputeID, {\n        from: account,\n        gas: process.env.GAS || undefined\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_REPARTITION_TOKENS)\n    }\n  }\n\n  /**\n   * Execute ruling on dispute\n   * @param {number} disputeID - index of the dispute.\n   * @param {string} account - address of user.\n   * @returns {object} - The result transaction object.\n   */\n  executeRuling = async (disputeID, account) => {\n    await this.loadContract()\n\n    try {\n      return this.contractInstance.executeRuling(disputeID, {\n        from: account\n      })\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_EXECUTE_RULING)\n    }\n  }\n\n  /**\n   * Get time for a period.\n   * @param {number} periodNumber - int representing period.\n   * @returns {number} - The seconds in the period.\n   */\n  getTimeForPeriod = async periodNumber => {\n    await this.loadContract()\n\n    let timePerPeriod\n\n    try {\n      timePerPeriod = await this.contractInstance.timePerPeriod(periodNumber)\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_TIME_PER_PERIOD)\n    }\n\n    if (timePerPeriod) return timePerPeriod.toNumber()\n\n    throw new Error(errorConstants.PERIOD_OUT_OF_RANGE(periodNumber))\n  }\n\n  /**\n   * Get dispute.\n   * @param {number} disputeID - The index of the dispute.\n   * @param {bool} withVoteCount - Whether to pull voteCounter data for a dispute.\n   * false by default for better performance.\n   * @returns {object} - The dispute data from the contract.\n   */\n  getDispute = async (disputeID, withVoteCount = false) => {\n    await this.loadContract()\n\n    try {\n      const dispute = await this.contractInstance.disputes(disputeID)\n      const numberOfAppeals = dispute[2].toNumber()\n      const rulingChoices = dispute[3].toNumber()\n\n      let voteCounters = []\n      const status = await this.contractInstance.disputeStatus(disputeID)\n      if (withVoteCount) {\n        for (let appeal = 0; appeal <= numberOfAppeals; appeal++) {\n          const voteCounts = []\n          for (let choice = 0; choice <= rulingChoices; choice++)\n            voteCounts.push(\n              this.contractInstance\n                .getVoteCount(disputeID, appeal, choice)\n                .then(v => v.toNumber())\n            )\n          voteCounters.push(voteCounts)\n        }\n\n        voteCounters = await Promise.all(\n          voteCounters.map(voteCounts => Promise.all(voteCounts))\n        )\n      }\n\n      return {\n        arbitratorAddress: this.contractAddress,\n        disputeID,\n        arbitrableContractAddress: dispute[0],\n        firstSession: dispute[1].toNumber(),\n        numberOfAppeals,\n        rulingChoices,\n        initialNumberJurors: dispute[4].toNumber(),\n        arbitrationFeePerJuror: dispute[5],\n        state: dispute[6].toNumber(),\n        voteCounters,\n        status: status ? status.toNumber() : null\n      }\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_DISPUTE)\n    }\n  }\n\n  /**\n   * Get number of jurors for a dispute.\n   * @param {number} disputeID - Index of dispute.\n   * @returns {number} - Number of jurors for a dispute.\n   */\n  getAmountOfJurorsForDispute = async disputeID => {\n    await this.loadContract()\n\n    let amountOfJurors\n\n    try {\n      amountOfJurors = await this.contractInstance.amountJurors(disputeID)\n    } catch (err) {\n      console.error(err)\n      throw new Error(errorConstants.UNABLE_TO_FETCH_AMOUNT_OF_JURORS)\n    }\n\n    if (amountOfJurors) return amountOfJurors.toNumber()\n\n    throw new Error(errorConstants.DISPUTE_DOES_NOT_EXIST)\n  }\n\n  /**\n   * Get number of jurors for a dispute.\n   * @param {number} disputeID - Index of dispute.\n   * @param {number} draw - Int for draw.\n   * @param {string} jurorAddress - Address of juror.\n   * @returns {bool} - `true` indicates juror has a vote for draw, `false` indicates they do not.\n   */\n  isJurorDrawnForDispute = async (disputeID, draw, jurorAddress) => {\n    await this.loadContract()\n\n    const isDrawn = await this.contractInstance.isDrawn(\n      disputeID,\n      jurorAddress,\n      draw\n    )\n\n    return isDrawn\n  }\n\n  /**\n   * Can juror currently rule in dispute.\n   * @param {number} disputeID - index of dispute.\n   * @param {int[]} draws - voting positions for dispute.\n   * @param {string} account - address of user.\n   * @returns {bool} - Boolean indicating if juror can rule or not.\n   */\n  canRuleDispute = async (disputeID, draws, account) => {\n    await this.loadContract()\n\n    const validDraws = await this.contractInstance.validDraws(\n      account,\n      disputeID,\n      draws\n    )\n\n    const lastRuling = (await this.contractInstance.getLastSessionVote(\n      disputeID,\n      account\n    )).toNumber()\n\n    const currentSession = await this.getSession()\n    const period = await this.getPeriod()\n    return (\n      validDraws &&\n      lastRuling !== currentSession &&\n      period < arbitratorConstants.PERIOD.APPEAL\n    )\n  }\n\n  /**\n   * Get number of jurors for a dispute.\n   * @param {number} disputeID - Index of dispute.\n   * @param {number} appeal - Index of appeal.\n   * @returns {number} - Int indicating the ruling of the dispute.\n   */\n  currentRulingForDispute = async (disputeID, appeal) => {\n    await this.loadContract()\n\n    const ruling = await this.contractInstance.getWinningChoice(\n      disputeID,\n      appeal\n    )\n\n    return ruling.toNumber()\n  }\n\n  /**\n   * Get current period of the contract\n   * @returns {number} - Int indicating the period.\n   */\n  getPeriod = async () => {\n    await this.loadContract()\n\n    const currentPeriod = await this.contractInstance.period()\n\n    return currentPeriod.toNumber()\n  }\n\n  /**\n   * Get min activated tokens for a session\n   * @returns {number} - Number of tokens as a BigNumber\n   */\n  getMinActivatedToken = async () => {\n    await this.loadContract()\n\n    return this.contractInstance.minActivatedToken()\n  }\n\n  /**\n   * Get current session of the contract.\n   * @returns {number} - Int indicating the session.\n   */\n  getSession = async () => {\n    await this.loadContract()\n\n    const currentSession = await this.contractInstance.session()\n\n    return currentSession.toNumber()\n  }\n\n  /**\n   * Get disputes from Kleros contract.\n   * @param {string} account - Address of user.\n   * @param {string} openDisputes - <optional> Pass open disputes from cached source\n   * @returns {object[]} - Array of disputes.\n   */\n  getDisputesForJuror = async (account, openDisputes) => {\n    await this.loadContract()\n\n    // contract data\n    if (!openDisputes) openDisputes = await this.getOpenDisputesForSession()\n\n    const disputes = await Promise.all(\n      openDisputes.map(async disputeData => {\n        const draws = await this.getDrawsForJuror(\n          disputeData.disputeID,\n          account\n        )\n        disputeData.appealDraws = disputeData.appealDraws || []\n        disputeData.appealDraws[disputeData.numberOfAppeals] = draws\n\n        return disputeData\n      })\n    )\n\n    return disputes\n  }\n\n  /**\n   * Fetch the votes a juror has in a dispute.\n   * @param {number} disputeID - ID of the dispute.\n   * @param {string} account - Potential jurors address.\n   * @returns {number[]} - Array of integers indicating the draw.\n   */\n  getDrawsForJuror = async (disputeID, account) => {\n    await this.loadContract()\n\n    const numberOfJurors = await this.getAmountOfJurorsForDispute(disputeID)\n    const draws = []\n    for (let draw = 1; draw <= numberOfJurors; draw++) {\n      const isJuror = await this.isJurorDrawnForDispute(\n        disputeID,\n        draw,\n        account\n      )\n      if (isJuror) {\n        draws.push(draw)\n      }\n    }\n    return draws\n  }\n\n  /** Get all disputes that are active this session.\n   * @returns {int[]} - array of active disputeID\n   */\n  getOpenDisputesForSession = async () => {\n    await this.loadContract()\n    const period = (await this.contractInstance.period()).toNumber()\n\n    // There are never any open disputes before VOTE. Don't want to populate cache\n    if (period < arbitratorConstants.PERIOD.VOTE) return []\n\n    const currentSession = await this.getSession()\n    if (this._openDisputesCache[currentSession])\n      return this._openDisputesCache[currentSession]\n    const openDisputes = []\n\n    let disputeID = 0\n    let dispute\n    while (1) {\n      // Iterate over all the disputes\n      // TODO: Implement a more performant solution\n      try {\n        dispute = await this.getDispute(disputeID)\n      } catch (err) {\n        // Dispute out of range, break\n        if (err.message === errorConstants.UNABLE_TO_FETCH_DISPUTE) break\n        console.error(err)\n        throw err\n      }\n      // Dispute has no arbitrable contract, break\n      if (dispute.arbitrableContractAddress === ethConstants.NULL_ADDRESS) break\n\n      // If dispute is in the current session, add it to the result array\n      if (dispute.firstSession + dispute.numberOfAppeals === currentSession)\n        openDisputes.push(dispute)\n\n      // Advance to the next dispute\n      disputeID++\n    }\n\n    this._openDisputesCache[currentSession] = openDisputes\n    return openDisputes\n  }\n\n  /**\n   * Fetch how a juror ruled in a dispute\n   * @param {number} disputeID The index of the dispute\n   * @param {number} appeal The index of the appeal\n   * @param {string} address The users ETH address\n   * @returns {number} The ruling that the juror gave\n   */\n  getVoteForJuror = async (disputeID, appeal, address) => {\n    await this.loadContract()\n\n    const numberOfJurors = await this.getAmountOfJurorsForDispute(disputeID)\n    let jurorDraw = null\n    for (let i = 0; i < numberOfJurors; i++) {\n      const jurorAddress = await this.contractInstance.getVoteAccount(\n        disputeID,\n        appeal,\n        i\n      )\n\n      // NOTE jurors can only vote once per session so this is safe for now.\n      if (jurorAddress === address) {\n        jurorDraw = i\n        break\n      }\n    }\n\n    if (_.isNull(jurorDraw)) return null\n\n    return this.getVoteForDraw(disputeID, appeal, jurorDraw)\n  }\n\n  /**\n   * Get the ruling that a juror gave in dispute\n   * @param {number} disputeID - the index of the dispute.\n   * @param {number} appeal - the index of the appeal.\n   * @param {number} draw - the index of the vote draw.\n   * @returns {number} ruling.\n   */\n  getVoteForDraw = async (disputeID, appeal, draw) => {\n    await this.loadContract()\n\n    const vote = await this.contractInstance.getVoteRuling(\n      disputeID,\n      appeal,\n      draw\n    )\n\n    return vote.toNumber()\n  }\n\n  /**\n   * Find when a ruling was made in a session\n   * @param {number} session - The session number.\n   * @returns {number[]} an array of timestamps\n   */\n  getAppealRuledAtTimestamp = async session => {\n    if (this._appealRuledAtTimestampCache[session])\n      return this._appealRuledAtTimestampCache[session]\n    const eventLog = await this._getNewPeriodEventLogForSession(\n      session,\n      arbitratorConstants.PERIOD.APPEAL\n    )\n    // May not have happened yet\n    if (!eventLog) return null\n\n    const ruledAtTimestamp = await this._getTimestampForBlock(\n      eventLog.blockNumber\n    )\n\n    const timestamp = ruledAtTimestamp * 1000\n    this._appealRuledAtTimestampCache[session] = timestamp\n    return timestamp\n  }\n\n  /**\n   * Find the deadline for disputes in a session.\n   * @param {number} session - The session number.\n   * @returns {number[]} an array of timestamps\n   */\n  getDisputeDeadlineTimestamp = async session => {\n    if (this._disputeDeadlineCache[session])\n      return this._disputeDeadlineCache[session]\n\n    const eventLog = await this._getNewPeriodEventLogForSession(\n      session,\n      arbitratorConstants.PERIOD.VOTE\n    )\n    // May not have happened yet\n    if (!eventLog) return null\n\n    // Fetch length of Vote period\n    const periodLength = await this.getTimeForPeriod(\n      arbitratorConstants.PERIOD.VOTE\n    )\n    // Get the time that the period started\n    const periodStartTimestamp = await this._getTimestampForBlock(\n      eventLog.blockNumber\n    )\n\n    const deadline = (periodLength + periodStartTimestamp) * 1000\n    this._disputeDeadlineCache[session] = deadline\n    return deadline\n  }\n\n  /**\n   * Get the event log for an appeal creation\n   * @param {number} session - The session number.\n   * @returns {number[]} an array of timestamps\n   */\n  getAppealCreationTimestamp = async session => {\n    if (this._appealCreationTimestampCache[session])\n      return this._appealCreationTimestampCache[session]\n    const eventLog = await this._getNewPeriodEventLogForSession(\n      session,\n      arbitratorConstants.PERIOD.EXECUTE\n    )\n\n    // May not have happened yet\n    if (!eventLog) return null\n\n    const createdAtTimestamp = await this._getTimestampForBlock(\n      eventLog.blockNumber\n    )\n\n    const timestamp = createdAtTimestamp * 1000\n    this._appealCreationTimestampCache[session] = timestamp\n    return timestamp\n  }\n\n  /**\n   * Get the event log for the dispute creation.\n   * @param {number} disputeID - The block number that the dispute was created.\n   * @returns {object} dispute creation event log.\n   */\n  getDisputeCreationEvent = async disputeID => {\n    const eventLogs = await EventListener.getEventLogs(\n      this,\n      'DisputeCreation',\n      0,\n      'latest',\n      { _disputeID: disputeID }\n    )\n\n    for (let i = 0; i < eventLogs.length; i++) {\n      const log = eventLogs[i]\n\n      if (log.args._disputeID.toNumber() === disputeID) return log\n    }\n\n    return null\n  }\n\n  /**\n   * Get the amount of tokens won or lost by a juror for a dispute\n   * @param {number} disputeID The index of the dispute\n   * @param {string} account The account of the juror\n   * @returns {number} The net total PNK\n   */\n  getNetTokensForDispute = async (disputeID, account) => {\n    const eventLogs = await EventListener.getEventLogs(\n      this,\n      'TokenShift',\n      0,\n      'latest',\n      { _account: account }\n    )\n\n    let netPNK = 0\n    for (let i = 0; i < eventLogs.length; i++) {\n      const event = eventLogs[i]\n      if (event.args._disputeID.toNumber() === disputeID)\n        netPNK += event.args._amount.toNumber()\n    }\n\n    return netPNK\n  }\n\n  /**\n   * Get the timestamp from blockNumber\n   * @param {number} blockNumber - The block number\n   * @returns {number} timestamp\n   */\n  _getTimestampForBlock = async blockNumber =>\n    (await this._Web3Wrapper.getBlock(blockNumber)).timestamp\n\n  /**\n   * Get event NewPeriod event logs a period in a session.\n   * @param {number} session - The session number.\n   * @param {number} periodNumber - The period number we want logs for.\n   * @returns {object} event log object.\n   */\n  _getNewPeriodEventLogForSession = async (session, periodNumber) => {\n    const logs = await EventListener.getEventLogs(\n      this,\n      'NewPeriod',\n      0,\n      'latest',\n      { _session: [session] }\n    )\n    for (let i = 0; i < logs.length; i++) {\n      const eventLog = logs[i]\n      if (eventLog.args._period.toNumber() === periodNumber) return eventLog\n    }\n    // We have hit the latest event log and did not find data. Return all that we have.\n    return null\n  }\n\n  /**\n   * Get data from Kleros contract.\n   * TODO split these into their own methods for more flexability and speed\n   * @returns {object} - Data for kleros POC from contract.\n   */\n  getData = async () => {\n    await this.loadContract()\n\n    const timePerPeriod = await Promise.all([\n      this.getTimeForPeriod(arbitratorConstants.PERIOD.ACTIVATION),\n      this.getTimeForPeriod(arbitratorConstants.PERIOD.DRAW),\n      this.getTimeForPeriod(arbitratorConstants.PERIOD.VOTE),\n      this.getTimeForPeriod(arbitratorConstants.PERIOD.APPEAL),\n      this.getTimeForPeriod(arbitratorConstants.PERIOD.EXECUTE)\n    ])\n    const [\n      pinakionContractAddress,\n      rngContractAddress,\n      period,\n      session,\n      lastPeriodChange,\n      minActivatedToken\n    ] = await Promise.all([\n      this.contractInstance.pinakion(),\n      this.contractInstance.rng(),\n      this.contractInstance.period(),\n      this.contractInstance.session(),\n      this.contractInstance.lastPeriodChange(),\n      this.getMinActivatedToken()\n    ])\n\n    return {\n      pinakionContractAddress,\n      rngContractAddress,\n      period: period.toNumber(),\n      session: session.toNumber(),\n      lastPeriodChange: lastPeriodChange.toNumber(),\n      timePerPeriod,\n      minActivatedToken\n    }\n  }\n}\n\nexport default Kleros\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrator/Kleros.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 167,
    "kind": "class",
    "name": "Kleros",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrator/Kleros.js",
    "importStyle": "Kleros",
    "description": "Provides interaction with a Kleros contract on the blockchain.",
    "lineNumber": 15,
    "interface": false,
    "extends": [
      "src/contracts/ContractImplementation.js~ContractImplementation"
    ]
  },
  {
    "__docId__": 168,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#constructor",
    "access": "public",
    "description": "Create new Kleros Implementation.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of the Kleros contract."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "artifact",
        "description": "<optional> An alternate Kleros artifact can be\npassed for classes that inherit Kleros (such as KlerosPOC)"
      }
    ]
  },
  {
    "__docId__": 169,
    "kind": "member",
    "name": "_disputeDeadlineCache",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#_disputeDeadlineCache",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "_appealCreationTimestampCache",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#_appealCreationTimestampCache",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "_appealRuledAtTimestampCache",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#_appealRuledAtTimestampCache",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "name": "_openDisputesCache",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#_openDisputesCache",
    "access": "private",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": true,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros.deploy",
    "access": "public",
    "description": "STATIC: Deploy a Kleros contract on the blockchain.",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} truffle-contract Object | err The contract object or error deploy"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rngAddress",
        "description": "address of random number generator contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pnkAddress",
        "description": "address of pinakion contract"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "timesPerPeriod",
        "description": "array of 5 ints indicating the time limit for each period of contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "amout of eth to send to contract"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object NOTE: NOT Kleros Web3Wrapper"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The contract object or error deploy"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "member",
    "name": "transferPNKToArbitrator",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#transferPNKToArbitrator",
    "access": "public",
    "description": "Deposit PNK to the contract.",
    "lineNumber": 68,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Balance information including total PNK balance and activated tokens."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "The amount of PNK to deposit."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Balance information including total PNK balance and activated tokens."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "withdrawPNK",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#withdrawPNK",
    "access": "public",
    "description": "Withdraw PNK from the contract.",
    "lineNumber": 96,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Balance information including total PNK balance and activated tokens."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "The BigNumber amount of PNK to deposit."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Balance information including total PNK balance and activated tokens."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "getPNKBalance",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getPNKBalance",
    "access": "public",
    "description": "Get PNK Balances.",
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Balance information including total PNK balance and activated tokens."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Balance information including total PNK balance and activated tokens."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "member",
    "name": "activatePNK",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#activatePNK",
    "access": "public",
    "description": "Activate Pinakion tokens to be eligible to be a juror.",
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - PNK balance in wei."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "Amount in wei of tokens to activate."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "PNK balance in wei."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "member",
    "name": "getArbitrationCost",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getArbitrationCost",
    "access": "public",
    "description": "Fetch the cost of arbitration.",
    "lineNumber": 173,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The cost of arbitration as a BigNumber."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "contractExtraData",
        "description": "extra data from arbitrable contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The cost of arbitration as a BigNumber."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "member",
    "name": "getAppealCost",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getAppealCost",
    "access": "public",
    "description": "Fetch the cost of appeal.",
    "lineNumber": 190,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The cost of appeal as a BigNumber."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "bytes"
        ],
        "spread": false,
        "optional": false,
        "name": "contractExtraData",
        "description": "extra data from arbitrable contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The cost of appeal as a BigNumber."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "passPeriod",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#passPeriod",
    "access": "public",
    "description": "Call contract to move on to the next period.",
    "lineNumber": 206,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - resulting object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "resulting object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "name": "submitVotes",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#submitVotes",
    "access": "public",
    "description": "Submit votes. Note can only be called during Voting period (Period 2).",
    "lineNumber": 227,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ruling",
        "description": "int representing the jurors decision."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "votes",
        "description": "int[] of drawn votes for dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "appealRuling",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#appealRuling",
    "access": "public",
    "description": "Appeal ruling on dispute.",
    "lineNumber": 248,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "Index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "extraData",
        "description": "Extra data."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "member",
    "name": "repartitionJurorTokens",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#repartitionJurorTokens",
    "access": "public",
    "description": "Repartition juror tokens.",
    "lineNumber": 268,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "executeRuling",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#executeRuling",
    "access": "public",
    "description": "Execute ruling on dispute",
    "lineNumber": 288,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "member",
    "name": "getTimeForPeriod",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getTimeForPeriod",
    "access": "public",
    "description": "Get time for a period.",
    "lineNumber": 306,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The seconds in the period."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "periodNumber",
        "description": "int representing period."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The seconds in the period."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "member",
    "name": "getDispute",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getDispute",
    "access": "public",
    "description": "Get dispute.",
    "lineNumber": 330,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The dispute data from the contract."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "withVoteCount",
        "description": "Whether to pull voteCounter data for a dispute.\nfalse by default for better performance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The dispute data from the contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "getAmountOfJurorsForDispute",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getAmountOfJurorsForDispute",
    "access": "public",
    "description": "Get number of jurors for a dispute.",
    "lineNumber": 382,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Number of jurors for a dispute."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "Index of dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Number of jurors for a dispute."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "isJurorDrawnForDispute",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#isJurorDrawnForDispute",
    "access": "public",
    "description": "Get number of jurors for a dispute.",
    "lineNumber": 406,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{bool} - `true` indicates juror has a vote for draw, `false` indicates they do not."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "Index of dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "draw",
        "description": "Int for draw."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "jurorAddress",
        "description": "Address of juror."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": "`true` indicates juror has a vote for draw, `false` indicates they do not."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "canRuleDispute",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#canRuleDispute",
    "access": "public",
    "description": "Can juror currently rule in dispute.",
    "lineNumber": 425,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{bool} - Boolean indicating if juror can rule or not."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "index of dispute."
      },
      {
        "nullable": null,
        "types": [
          "int[]"
        ],
        "spread": false,
        "optional": false,
        "name": "draws",
        "description": "voting positions for dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": "Boolean indicating if juror can rule or not."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "currentRulingForDispute",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#currentRulingForDispute",
    "access": "public",
    "description": "Get number of jurors for a dispute.",
    "lineNumber": 454,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Int indicating the ruling of the dispute."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "Index of dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "Index of appeal."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Int indicating the ruling of the dispute."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "getPeriod",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getPeriod",
    "access": "public",
    "description": "Get current period of the contract",
    "lineNumber": 469,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Int indicating the period."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Int indicating the period."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "getMinActivatedToken",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getMinActivatedToken",
    "access": "public",
    "description": "Get min activated tokens for a session",
    "lineNumber": 481,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Number of tokens as a BigNumber"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Number of tokens as a BigNumber"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "member",
    "name": "getSession",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getSession",
    "access": "public",
    "description": "Get current session of the contract.",
    "lineNumber": 491,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Int indicating the session."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Int indicating the session."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "member",
    "name": "getDisputesForJuror",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getDisputesForJuror",
    "access": "public",
    "description": "Get disputes from Kleros contract.",
    "lineNumber": 505,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of disputes."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "openDisputes",
        "description": "<optional> Pass open disputes from cached source"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of disputes."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "member",
    "name": "getDrawsForJuror",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getDrawsForJuror",
    "access": "public",
    "description": "Fetch the votes a juror has in a dispute.",
    "lineNumber": 533,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number[]} - Array of integers indicating the draw."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "ID of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Potential jurors address."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "Array of integers indicating the draw."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "getOpenDisputesForSession",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getOpenDisputesForSession",
    "access": "public",
    "description": "Get all disputes that are active this session.",
    "lineNumber": 554,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{int[]} - array of active disputeID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "int[]"
      ],
      "spread": false,
      "description": "array of active disputeID"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "getVoteForJuror",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getVoteForJuror",
    "access": "public",
    "description": "Fetch how a juror ruled in a dispute",
    "lineNumber": 601,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The ruling that the juror gave"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "The index of the appeal"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "address",
        "description": "The users ETH address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The ruling that the juror gave"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "getVoteForDraw",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getVoteForDraw",
    "access": "public",
    "description": "Get the ruling that a juror gave in dispute",
    "lineNumber": 632,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} ruling."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "the index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "the index of the appeal."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "draw",
        "description": "the index of the vote draw."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "ruling."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "getAppealRuledAtTimestamp",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getAppealRuledAtTimestamp",
    "access": "public",
    "description": "Find when a ruling was made in a session",
    "lineNumber": 649,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number[]} an array of timestamps"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "The session number."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "an array of timestamps"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "getDisputeDeadlineTimestamp",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getDisputeDeadlineTimestamp",
    "access": "public",
    "description": "Find the deadline for disputes in a session.",
    "lineNumber": 673,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number[]} an array of timestamps"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "The session number."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "an array of timestamps"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "getAppealCreationTimestamp",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getAppealCreationTimestamp",
    "access": "public",
    "description": "Get the event log for an appeal creation",
    "lineNumber": 703,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number[]} an array of timestamps"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "The session number."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "an array of timestamps"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "member",
    "name": "getDisputeCreationEvent",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getDisputeCreationEvent",
    "access": "public",
    "description": "Get the event log for the dispute creation.",
    "lineNumber": 728,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} dispute creation event log."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The block number that the dispute was created."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "dispute creation event log."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "member",
    "name": "getNetTokensForDispute",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getNetTokensForDispute",
    "access": "public",
    "description": "Get the amount of tokens won or lost by a juror for a dispute",
    "lineNumber": 752,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The net total PNK"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account of the juror"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The net total PNK"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "member",
    "name": "_getTimestampForBlock",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#_getTimestampForBlock",
    "access": "private",
    "description": "Get the timestamp from blockNumber",
    "lineNumber": 776,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} timestamp"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "blockNumber",
        "description": "The block number"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "timestamp"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "_getNewPeriodEventLogForSession",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#_getNewPeriodEventLogForSession",
    "access": "private",
    "description": "Get event NewPeriod event logs a period in a session.",
    "lineNumber": 785,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} event log object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "The session number."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "periodNumber",
        "description": "The period number we want logs for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "event log object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "member",
    "name": "getData",
    "memberof": "src/contracts/implementations/arbitrator/Kleros.js~Kleros",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/Kleros.js~Kleros#getData",
    "access": "public",
    "description": "Get data from Kleros contract.\nTODO split these into their own methods for more flexability and speed",
    "lineNumber": 806,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Data for kleros POC from contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Data for kleros POC from contract."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrator/KlerosPOC.js",
    "content": "import klerosPOCArtifact from 'kleros/build/contracts/KlerosPOC'\nimport _ from 'lodash'\n\nimport * as ethConstants from '../../../constants/eth'\nimport deployContractAsync from '../../../utils/deployContractAsync'\n\nimport Kleros from './Kleros'\n\n/**\n * Provides interaction with a KlerosPOC contract on the blockchain.\n */\nclass KlerosPOC extends Kleros {\n  /**\n   * Create new KlerosPOC Implementation.\n   * @param {object} web3Provider - web3 instance.\n   * @param {string} contractAddress - Address of the KlerosPOC contract.\n   */\n  constructor(web3Provider, contractAddress) {\n    super(web3Provider, contractAddress, klerosPOCArtifact)\n  }\n\n  /**\n   * STATIC: Deploy a KlerosPOC contract on the blockchain.\n   * @param {string} rngAddress address of random number generator contract\n   * @param {string} pnkAddress address of pinakion contract\n   * @param {number[]} timesPerPeriod array of 5 ints indicating the time limit for each period of contract\n   * @param {string} account address of user\n   * @param {number} value amout of eth to send to contract\n   * @param {object} web3Provider web3 provider object NOTE: NOT Kleros Web3Wrapper\n   * @returns {object} truffle-contract Object | err The contract object or error deploy\n   */\n  static deploy = async (\n    rngAddress,\n    pnkAddress,\n    timesPerPeriod = [300, 0, 300, 300, 300],\n    account,\n    value = ethConstants.TRANSACTION.VALUE,\n    web3Provider\n  ) => {\n    const contractDeployed = await deployContractAsync(\n      account,\n      value,\n      klerosPOCArtifact,\n      web3Provider,\n      pnkAddress,\n      rngAddress,\n      timesPerPeriod\n    )\n\n    return contractDeployed\n  }\n\n  /**\n   * Purchase PNK.\n   * @param {string} amount - The amount of pinakion to buy in wei.\n   * @param {string} account - The address of the user.\n   * @returns {object} - The result transaction object.\n   */\n  buyPNK = async (amount, account) => {\n    await this.loadContract()\n    return this.contractInstance.buyPinakion({\n      from: account,\n      value: amount,\n      gas: process.env.GAS || undefined\n    })\n  }\n}\n\nexport default KlerosPOC\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrator/KlerosPOC.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 208,
    "kind": "class",
    "name": "KlerosPOC",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js",
    "static": true,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/contracts/implementations/arbitrator/KlerosPOC.js",
    "importStyle": "KlerosPOC",
    "description": "Provides interaction with a KlerosPOC contract on the blockchain.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "src/contracts/implementations/arbitrator/Kleros.js~Kleros"
    ]
  },
  {
    "__docId__": 209,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#constructor",
    "access": "public",
    "description": "Create new KlerosPOC Implementation.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of the KlerosPOC contract."
      }
    ]
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "deploy",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": true,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC.deploy",
    "access": "public",
    "description": "STATIC: Deploy a KlerosPOC contract on the blockchain.",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} truffle-contract Object | err The contract object or error deploy"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rngAddress",
        "description": "address of random number generator contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "pnkAddress",
        "description": "address of pinakion contract"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "timesPerPeriod",
        "description": "array of 5 ints indicating the time limit for each period of contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "amout of eth to send to contract"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "web3 provider object NOTE: NOT Kleros Web3Wrapper"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The contract object or error deploy"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "member",
    "name": "buyPNK",
    "memberof": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC",
    "static": false,
    "longname": "src/contracts/implementations/arbitrator/KlerosPOC.js~KlerosPOC#buyPNK",
    "access": "public",
    "description": "Purchase PNK.",
    "lineNumber": 59,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The result transaction object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "amount",
        "description": "The amount of pinakion to buy in wei."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The result transaction object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "file",
    "name": "src/contracts/implementations/arbitrator/index.js",
    "content": "import KlerosPOC from './KlerosPOC'\n\nexport { KlerosPOC }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/arbitrator/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 213,
    "kind": "file",
    "name": "src/contracts/implementations/index.js",
    "content": "import * as arbitrator from './arbitrator'\nimport * as arbitrable from './arbitrable'\nimport * as PNK from './PNK'\nimport * as RNG from './RNG'\n\nexport { arbitrator, arbitrable, PNK, RNG }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/implementations/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 214,
    "kind": "file",
    "name": "src/contracts/index.js",
    "content": "import * as abstractions from './abstractions'\nimport * as implementations from './implementations'\n\nexport { abstractions, implementations }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/contracts/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 215,
    "kind": "file",
    "name": "src/index.js",
    "content": "import Kleros from './kleros.js'\n\nexport { Kleros }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 216,
    "kind": "file",
    "name": "src/kleros.js",
    "content": "import isRequired from './utils/isRequired'\nimport Web3Wrapper from './utils/Web3Wrapper'\nimport StoreProviderWrapper from './utils/StoreProviderWrapper'\nimport * as contracts from './contracts'\nimport * as resources from './resources'\nimport EventListener from './utils/EventListener'\n\n/**\n * The Kleros Api provides access to the full suite of functionality. It will initialize\n * contract instances for you when possible and creates an object that you can use to\n * call all of the other api modules. If you are only going to be interacting with\n * specific apis, or you don't want certain functionality such as the off chain store,\n * you might find it easier to initialze a specific instance of the api you want.\n */\nclass Kleros {\n  web3Wrapper = {}\n\n  storeWrapper = {}\n\n  eventListener = null\n\n  /**\n   * Instantiates a new Kelros instance that provides the public interface\n   * to Kleros contracts and library. All params are required. To use an individual\n   * portion of the API import a class and initialize it yourself.\n   * @param {string} ethereumProvider - The Web3.js Provider instance you would like the\n   *                 Kleros.js library to use for interacting with the\n   *                 Ethereum network.\n   * @param {string} storeUri - The storage provider uri used to\n   *                      get metadata from the cloud for the UI. e.g. Kleros-Store,\n   *                      IPFS, Swarm etc.\n   * @param {string} arbitratorAddress - Address of the arbitrator contract we should\n   *                 use when initializing KlerosPOC\n   * @param {string} arbitrableContractAddress - Address of the arbitrator contract we should\n   *                 use when initializing KlerosPOC\n   */\n  constructor(\n    ethereumProvider = isRequired('ethereumProvider'),\n    storeUri = isRequired('storeUri'),\n    arbitratorAddress,\n    arbitrableContractAddress\n  ) {\n    /**\n     * We need a set of implementations that we expose to the outside api and a set we use\n     * internally. This is because the implementation class itself sets the contract instance\n     * and we don't want race conditions between external and internal calls.\n     *\n     * FIXME this is an ugly way of doing this and still has some race conditions. See issue #138.\n     */\n    // EXTERNAL\n    const _klerosPOC = new contracts.implementations.arbitrator.KlerosPOC(\n      ethereumProvider,\n      arbitratorAddress\n    )\n    const _arbitrableTransaction = new contracts.implementations.arbitrable.MultipleArbitrableTransaction(\n      ethereumProvider,\n      arbitrableContractAddress\n    )\n    // INTERNAL\n    const _klerosPOCInternal = new contracts.implementations.arbitrator.KlerosPOC(\n      ethereumProvider,\n      arbitratorAddress\n    )\n    const _arbitrableTransactionInternal = new contracts.implementations.arbitrable.MultipleArbitrableTransaction(\n      ethereumProvider,\n      arbitrableContractAddress\n    )\n\n    // **************************** //\n    // *   INITIALIZED CLASSES    * //\n    // **************************** //\n    // KLEROS WRAPPERS\n    this.web3Wrapper = new Web3Wrapper(ethereumProvider)\n    this.storeWrapper = new StoreProviderWrapper(storeUri)\n    // ARBITRATOR\n    this.arbitrator = new contracts.abstractions.Arbitrator(\n      _klerosPOC,\n      this.storeWrapper\n    )\n    // ARBITRABLE CONTRACTS\n    this.arbitrable = new contracts.abstractions.Arbitrable(\n      _arbitrableTransaction,\n      this.storeWrapper\n    )\n\n    // Create new instance of arbitator and arbitrable for behind the scene task runners to use\n    const _arbitrator = new contracts.abstractions.Arbitrator(\n      _klerosPOCInternal,\n      this.storeWrapper\n    )\n    const _arbitrable = new contracts.abstractions.Arbitrable(\n      _arbitrableTransactionInternal,\n      this.storeWrapper\n    )\n    // DISPUTES\n    this.disputes = new resources.Disputes(\n      _arbitrator,\n      _arbitrable,\n      this.storeWrapper\n    )\n    // NOTIFICATIONS\n    this.notifications = new resources.Notifications(\n      _arbitrator,\n      _arbitrable,\n      this.storeWrapper\n    )\n    // AUTH\n    this.auth = new resources.Auth(this.web3Wrapper, this.storeWrapper)\n  }\n\n  /**\n   * Set a new arbitrable contract for Kleros instance of arbitrableContracts\n   * @param {string} contractAddress - Address of arbitrable contract\n   */\n  setArbitrableContractAddress = contractAddress => {\n    this.arbitrable.setContractInstance(contractAddress)\n  }\n\n  /**\n   * Bootstraps an EventListener and adds all Kleros handlers for event logs. Use\n   * this if you want to watch the chain for notifications, or are using the off chain\n   * store for metadata.\n   * @param {string} account Address of the user\n   * @param {function} callback The function to be called once a notification\n   * @returns {Promise} the watcher promise so that user can wait for event watcher to start before taking other actions.\n   */\n  watchForEvents = async (\n    account,\n    callback // for notification callback\n  ) => {\n    // stop current event listeners\n    if (this.eventListener) {\n      this.eventListener.stopWatchingForEvents()\n    }\n    // reinitialize with current arbitrator contract instance\n    this.eventListener = new EventListener([this.arbitrator])\n    // add handlers for notifications\n    this.notifications.registerArbitratorNotifications(\n      account,\n      this.eventListener,\n      callback\n    )\n    // add handlers for event driven store updates\n    this.disputes.registerStoreUpdateEventListeners(account, this.eventListener)\n    // fetch last block for user\n    const fromBlock = await this.storeWrapper.getLastBlock(account)\n    // start event listener\n    return this.eventListener.watchForEvents(fromBlock)\n  }\n\n  /**\n   * Stop watching for events on the Arbitrator initialized in the Kleros Instance.\n   */\n  stopWatchingForEvents = () => {\n    if (this.eventListener)\n      this.eventListener.removeContractInstance(this.arbitrator)\n  }\n\n  /**\n   * Sets the store provider uri for all higher level apis in the Kleros Instance.\n   * @param {string} storeUri - The URI that the store provider will use\n   */\n  setStoreProvider = storeUri => {\n    this.storeWrapper = new StoreProviderWrapper(storeUri)\n\n    this.disputes.setStoreProviderInstance(this.storeWrapper)\n    this.arbitrable.setStoreProviderInstance(this.storeWrapper)\n    this.arbitrator.setStoreProviderInstance(this.storeWrapper)\n    this.notifications.setStoreProviderInstance(this.storeWrapper)\n    this.auth.setStoreProviderInstance(this.storeWrapper)\n  }\n}\n\nexport default Kleros\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/kleros.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 217,
    "kind": "class",
    "name": "Kleros",
    "memberof": "src/kleros.js",
    "static": true,
    "longname": "src/kleros.js~Kleros",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/kleros.js",
    "importStyle": "Kleros",
    "description": "The Kleros Api provides access to the full suite of functionality. It will initialize\ncontract instances for you when possible and creates an object that you can use to\ncall all of the other api modules. If you are only going to be interacting with\nspecific apis, or you don't want certain functionality such as the off chain store,\nyou might find it easier to initialze a specific instance of the api you want.",
    "lineNumber": 15,
    "interface": false
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "web3Wrapper",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#web3Wrapper",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "storeWrapper",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#storeWrapper",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "eventListener",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#eventListener",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/kleros.js~Kleros",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/kleros.js~Kleros#constructor",
    "access": "public",
    "description": "Instantiates a new Kelros instance that provides the public interface\nto Kleros contracts and library. All params are required. To use an individual\nportion of the API import a class and initialize it yourself.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ethereumProvider",
        "description": "The Web3.js Provider instance you would like the\n                Kleros.js library to use for interacting with the\n                Ethereum network."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "storeUri",
        "description": "The storage provider uri used to\n                     get metadata from the cloud for the UI. e.g. Kleros-Store,\n                     IPFS, Swarm etc."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "Address of the arbitrator contract we should\n                use when initializing KlerosPOC"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableContractAddress",
        "description": "Address of the arbitrator contract we should\n                use when initializing KlerosPOC"
      }
    ]
  },
  {
    "__docId__": 224,
    "kind": "member",
    "name": "arbitrator",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#arbitrator",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 225,
    "kind": "member",
    "name": "arbitrable",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#arbitrable",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "member",
    "name": "disputes",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#disputes",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "notifications",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#notifications",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "member",
    "name": "auth",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#auth",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "member",
    "name": "setArbitrableContractAddress",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#setArbitrableContractAddress",
    "access": "public",
    "description": "Set a new arbitrable contract for Kleros instance of arbitrableContracts",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of arbitrable contract"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "member",
    "name": "watchForEvents",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#watchForEvents",
    "access": "public",
    "description": "Bootstraps an EventListener and adds all Kleros handlers for event logs. Use\nthis if you want to watch the chain for notifications, or are using the off chain\nstore for metadata.",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} the watcher promise so that user can wait for event watcher to start before taking other actions."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of the user"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The function to be called once a notification"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "the watcher promise so that user can wait for event watcher to start before taking other actions."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "member",
    "name": "stopWatchingForEvents",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#stopWatchingForEvents",
    "access": "public",
    "description": "Stop watching for events on the Arbitrator initialized in the Kleros Instance.",
    "lineNumber": 154,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "member",
    "name": "setStoreProvider",
    "memberof": "src/kleros.js~Kleros",
    "static": false,
    "longname": "src/kleros.js~Kleros#setStoreProvider",
    "access": "public",
    "description": "Sets the store provider uri for all higher level apis in the Kleros Instance.",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "storeUri",
        "description": "The URI that the store provider will use"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "file",
    "name": "src/resources/Auth.js",
    "content": "import Personal from 'web3-eth-personal'\n\nimport isRequired from '../utils/isRequired'\nimport { UNABLE_TO_SIGN_TOKEN } from '../constants/error'\n\nclass Auth {\n  constructor(\n    web3Wrapper = isRequired('web3Wrapper'),\n    storeProviderInstance = isRequired('storeProviderInstance')\n  ) {\n    this._Web3Wrapper = web3Wrapper\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  /**\n   * Set an auth token in the Store Provider. Call this instead of validateNewAuthToken\n   * if you have a signed token saved.\n   * @param {string} token - Hex representation of signed token.\n   */\n  setAuthToken = token => {\n    this._StoreProviderInstance.setAuthToken(token)\n  }\n\n  /**\n   * Validate a new auth token. Note if you validate a new token old signed tokens\n   * will not longer be valid regardless of their expiration time.\n   * @param {string} userAddress - Address of the user profile\n   * @returns {string} Signed token for future use.\n   */\n  getNewAuthToken = async userAddress => {\n    const unsignedToken = (await this._StoreProviderInstance.newAuthToken(\n      userAddress\n    )).unsignedToken\n\n    const signedToken = await this.signMessage(userAddress, unsignedToken)\n    // make sure token is valid\n    if (!await this.validateAuthToken(userAddress, signedToken))\n      throw new Error(UNABLE_TO_SIGN_TOKEN)\n\n    return signedToken\n  }\n\n  /**\n   * Sign a message with your private key. Uses web3 1.0 personal sign\n   * @param {string} userAddress - The address with which we want to sign the message\n   * @param {string} data - Hex encoded data to sign\n   * @returns {string} signed data\n   */\n  signMessage = (userAddress, data) => {\n    const ethPersonal = new Personal(this._Web3Wrapper.getProvider())\n    return new Promise((resolve, reject) => {\n      ethPersonal.sign(data, userAddress, (error, result) => {\n        if (error) reject(error)\n\n        resolve(result)\n      })\n    })\n  }\n\n  /**\n   * Validate an auth token.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} authToken - Token to check.\n   * @returns {Promise} resolves to True if token is valid.\n   */\n  validateAuthToken = (userAddress, authToken) =>\n    this._StoreProviderInstance.isTokenValid(userAddress, authToken)\n}\n\nexport default Auth\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/Auth.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 236,
    "kind": "class",
    "name": "Auth",
    "memberof": "src/resources/Auth.js",
    "static": true,
    "longname": "src/resources/Auth.js~Auth",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/resources/Auth.js",
    "importStyle": "Auth",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 237,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/resources/Auth.js~Auth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/resources/Auth.js~Auth#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true
  },
  {
    "__docId__": 238,
    "kind": "member",
    "name": "_Web3Wrapper",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#_Web3Wrapper",
    "access": "private",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "member",
    "name": "_StoreProviderInstance",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#_StoreProviderInstance",
    "access": "private",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "member",
    "name": "setAuthToken",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#setAuthToken",
    "access": "public",
    "description": "Set an auth token in the Store Provider. Call this instead of validateNewAuthToken\nif you have a signed token saved.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "token",
        "description": "Hex representation of signed token."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "member",
    "name": "getNewAuthToken",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#getNewAuthToken",
    "access": "public",
    "description": "Validate a new auth token. Note if you validate a new token old signed tokens\nwill not longer be valid regardless of their expiration time.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} Signed token for future use."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of the user profile"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Signed token for future use."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "signMessage",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#signMessage",
    "access": "public",
    "description": "Sign a message with your private key. Uses web3 1.0 personal sign",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} signed data"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address with which we want to sign the message"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Hex encoded data to sign"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "signed data"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "validateAuthToken",
    "memberof": "src/resources/Auth.js~Auth",
    "static": false,
    "longname": "src/resources/Auth.js~Auth#validateAuthToken",
    "access": "public",
    "description": "Validate an auth token.",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} resolves to True if token is valid."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "authToken",
        "description": "Token to check."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "resolves to True if token is valid."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "file",
    "name": "src/resources/Disputes.js",
    "content": "import _ from 'lodash'\n\nimport * as arbitratorConstants from '../constants/arbitrator'\nimport * as disputeConstants from '../constants/dispute'\nimport isRequired from '../utils/isRequired'\n\n/**\n * Disputes API. Provides cross arbitrator and arbitrable contracts functionality.\n * Requires Store Provider to be set.\n */\nclass Disputes {\n  constructor(\n    arbitratorInstance = isRequired('arbitratorInstance'),\n    arbitrableInstance = isRequired('arbitrableInstance'),\n    storeProviderInstance = isRequired('storeProviderInstance')\n  ) {\n    this._ArbitratorInstance = arbitratorInstance\n    this._ArbitrableInstance = arbitrableInstance\n    this._StoreProviderInstance = storeProviderInstance\n    this.disputeCache = {}\n  }\n  /**\n   * Set arbitrator instance.\n   * @param {object} arbitratorInstance - instance of an arbitrator contract.\n   */\n  setArbitratorInstance = arbitratorInstance => {\n    this._ArbitratorInstance = arbitratorInstance\n  }\n  /**\n   * Set arbitrable instance.\n   * @param {object} arbitrableInstance - instance of an arbitrable contract.\n   */\n  setArbitrableInstance = arbitrableInstance => {\n    this._ArbitrableInstance = arbitrableInstance\n  }\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  // **************************** //\n  // *         Events           * //\n  // **************************** //\n\n  /**\n   * Method to register all dispute handlers to an EventListener.\n   * @param {string} account - The address of the user.\n   * @param {object} eventListener - The EventListener instance. See utils/EventListener.js.\n   */\n  registerStoreUpdateEventListeners = (\n    account = isRequired('account'),\n    eventListener = isRequired('eventListener')\n  ) => {\n    const eventHandlerMap = {\n      DisputeCreation: [this._storeNewDisputeHandler]\n    }\n\n    for (let event in eventHandlerMap) {\n      if (eventHandlerMap.hasOwnProperty(event)) {\n        eventHandlerMap[event].forEach(handler => {\n          eventListener.addEventHandler(this._ArbitratorInstance, event, args =>\n            handler(args, account)\n          )\n        })\n      }\n    }\n  }\n\n  /**\n   * Event listener handler that stores dispute in store upon creation\n   * @param {string} event - The event log.\n   * @param {string} account - Account of user to update store data for\n   */\n  _storeNewDisputeHandler = async (event, account) => {\n    // There is no need to handle this event if we are not using the store\n    const disputeID = event.args._disputeID.toNumber()\n\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n    // arbitrator data\n    const disputeData = await this._ArbitratorInstance.getDispute(disputeID)\n    // arbitrable contract data\n    await this._ArbitrableInstance.setContractInstance(\n      disputeData.arbitrableContractAddress\n    )\n\n    const arbitrableContractData = await this._ArbitrableInstance.getData(\n      account\n    )\n\n    if (\n      account === arbitrableContractData.partyA ||\n      account === arbitrableContractData.partyB\n    ) {\n      await this._StoreProviderInstance.updateDisputeProfile(\n        account,\n        arbitratorAddress,\n        disputeID,\n        {\n          contractAddress: disputeData.arbitrableContractAddress,\n          partyA: arbitrableContractData.partyA,\n          partyB: arbitrableContractData.partyB,\n          blockNumber: event.blockNumber\n        }\n      )\n    }\n  }\n\n  // **************************** //\n  // *        Internal          * //\n  // **************************** //\n\n  /**\n   * Add new data to the cache\n   * @param {number} disputeID - The index of the dispute. Used as the key in cache\n   * @param {object} newCacheData - Freeform data to cache. Will overwrite data with the same keys.\n   */\n  _updateDisputeCache = (disputeID, newCacheData = {}) => {\n    this.disputeCache[disputeID] = {\n      ...this.disputeCache[disputeID],\n      ...newCacheData\n    }\n  }\n\n  /**\n   * Get the block at which a dispute was created. Used to find timestamps for dispute.\n   * The start block is cached after it has been found once as it will never change.\n   * @param {number} disputeID - The index of the dispute.\n   * @param {string} account - The address of the user.\n   * @returns {number} The block number that the dispute was created.\n   */\n  _getDisputeStartBlock = async (disputeID, account) => {\n    const cachedDispute = this.disputeCache[disputeID]\n    if (cachedDispute && cachedDispute.startBlock)\n      return cachedDispute.startBlock\n\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n    let blockNumber\n\n    try {\n      const userData = await this._StoreProviderInstance.getDispute(\n        account,\n        arbitratorAddress,\n        disputeID\n      )\n      blockNumber = userData.blockNumber\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {}\n    // if block number is not stored we can look it up\n    if (!blockNumber) {\n      // Fetching a dispute will fail if it hasn't been added to the store yet. This is ok, we can just not return store data\n      // see if we can get dispute start block from events\n      const disputeCreationEvent = await this._ArbitratorInstance.getDisputeCreationEvent(\n        disputeID\n      )\n      if (disputeCreationEvent) {\n        blockNumber = disputeCreationEvent.blockNumber\n      }\n    }\n\n    // cache start block for dispute\n    this._updateDisputeCache(disputeID, { startBlock: blockNumber })\n    return blockNumber\n  }\n\n  // **************************** //\n  // *          Public          * //\n  // **************************** //\n  /**\n   * Fetch the shared dispute data from the store.\n   * @param {string} account - The users account.\n   * @param {string} disputeID - The index of the dispute.\n   * @returns {Promise} The dispute data in the store.\n   */\n  getDisputeFromStore = async (account, disputeID) => {\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n    return this._StoreProviderInstance.getDispute(\n      account,\n      arbitratorAddress,\n      disputeID\n    )\n  }\n\n  /**\n   * Get the dispute deadline for the appeal.\n   * @param {number} disputeID - The index of the dispute.\n   * @param {number} appeal - The appeal number. 0 if there have been no appeals.\n   * @returns {number} timestamp of the appeal\n   */\n  getDisputeDeadline = async (disputeID, appeal = 0) => {\n    const cachedDispute = this.disputeCache[disputeID] || {}\n    if (cachedDispute.appealDeadlines && cachedDispute.appealDeadlines[appeal])\n      return cachedDispute.appealDeadlines[appeal]\n\n    const dispute = await this._ArbitratorInstance.getDispute(disputeID)\n\n    const deadlineTimestamp = await this._ArbitratorInstance.getDisputeDeadlineTimestamp(\n      dispute.firstSession + appeal\n    )\n\n    if (deadlineTimestamp) {\n      const currentDeadlines = cachedDispute.appealDeadlines || []\n      currentDeadlines[appeal] = deadlineTimestamp\n      // cache the deadline for the appeal\n      this._updateDisputeCache(disputeID, {\n        appealDeadlines: currentDeadlines\n      })\n    }\n\n    return deadlineTimestamp\n  }\n\n  /**\n   * Get the timestamp on when the dispute's ruling was finalized.\n   * @param {number} disputeID - The index of the dispute.\n   * @param {number} appeal - The appeal number. 0 if there have been no appeals.\n   * @returns {number} timestamp of the appeal\n   */\n  getAppealRuledAt = async (disputeID, appeal = 0) => {\n    const cachedDispute = this.disputeCache[disputeID]\n    if (\n      cachedDispute &&\n      cachedDispute.appealRuledAt &&\n      cachedDispute.appealRuledAt[appeal]\n    )\n      return cachedDispute.appealRuledAt[appeal]\n\n    const dispute = await this._ArbitratorInstance.getDispute(disputeID)\n    const appealRuledAtTimestamp = await this._ArbitratorInstance.getAppealRuledAtTimestamp(\n      dispute.firstSession + appeal\n    )\n\n    // cache the deadline for the appeal\n    if (appealRuledAtTimestamp) {\n      const currentRuledAt = cachedDispute.appealRuledAt || []\n      currentRuledAt[appeal] = appealRuledAtTimestamp\n      this._updateDisputeCache(disputeID, {\n        appealRuledAt: currentRuledAt\n      })\n    }\n\n    return appealRuledAtTimestamp\n  }\n\n  /**\n   * Get the timestamp on when the dispute's appeal was created\n   * @param {number} disputeID - The index of the dispute.\n   * @param {string} account - The users address.\n   * @param {number} appeal - The appeal number. 0 if there have been no appeals.\n   * @returns {number} timestamp of the appeal\n   */\n  getAppealCreatedAt = async (disputeID, account, appeal = 0) => {\n    const cachedDispute = this.disputeCache[disputeID]\n    if (\n      cachedDispute &&\n      cachedDispute.appealCreatedAt &&\n      cachedDispute.appealCreatedAt[appeal]\n    )\n      return cachedDispute.appealCreatedAt[appeal]\n\n    const dispute = await this._ArbitratorInstance.getDispute(disputeID)\n\n    let appealCreatedAtTimestamp = null\n    if (appeal === 0) {\n      const creationBlock = await this._getDisputeStartBlock(disputeID, account)\n      if (creationBlock) {\n        const timestampSeconds = await this._ArbitratorInstance._getTimestampForBlock(\n          creationBlock\n        )\n\n        appealCreatedAtTimestamp = timestampSeconds * 1000\n      }\n    } else {\n      appealCreatedAtTimestamp = await this._ArbitratorInstance.getAppealCreationTimestamp(\n        dispute.firstSession + (appeal - 1) // appeal was created during previous session\n      )\n\n      // cache the deadline for the appeal\n      if (appealCreatedAtTimestamp) {\n        const currentCreatedAt = cachedDispute.appealCreatedAt || []\n        currentCreatedAt[appeal] = appealCreatedAtTimestamp\n        this._updateDisputeCache(disputeID, {\n          appealCreatedAt: currentCreatedAt\n        })\n      }\n    }\n\n    return appealCreatedAtTimestamp\n  }\n\n  /**\n   * Get data for a dispute. This method provides data from the store as well as both\n   * arbitrator and arbitrable contracts. Used to get all relevant data on a dispute.\n   * @param {number} disputeID - The dispute's ID.\n   * @param {string} account - The juror's address.\n   * @returns {object} - Data object for the dispute that uses data from the contract and the store.\n   */\n  getDataForDispute = async (disputeID, account) => {\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n    // Get dispute data from contract. Also get the current session and period.\n    const [dispute, period, session] = await Promise.all([\n      this._ArbitratorInstance.getDispute(disputeID, true),\n      this._ArbitratorInstance.getPeriod(),\n      this._ArbitratorInstance.getSession()\n    ])\n\n    // Get arbitrable contract data and evidence\n    const arbitrableContractAddress = dispute.arbitrableContractAddress\n    await this._ArbitrableInstance.setContractInstance(\n      arbitrableContractAddress\n    )\n    const [metaEvidence, evidence, parties] = await Promise.all([\n      this._ArbitrableInstance.getMetaEvidence(),\n      this._ArbitrableInstance.getEvidence(),\n      this._ArbitrableInstance.getParties()\n    ])\n\n    // Get dispute data from the store\n    let appealDraws = []\n\n    // get draws if they have been added to store.\n    try {\n      const userData = await this._StoreProviderInstance.getDispute(\n        account,\n        arbitratorAddress,\n        disputeID\n      )\n      if (userData.appealDraws) appealDraws = userData.appealDraws || []\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      // Dispute exists on chain but not in store. We have lost draws for past disputes.\n      console.error('Dispute does not exist in store.')\n    }\n\n    const netPNK = await this._ArbitratorInstance.getNetTokensForDispute(\n      disputeID,\n      account\n    )\n\n    // Build juror info and ruling arrays, indexed by appeal number\n    const lastSession = dispute.firstSession + dispute.numberOfAppeals\n    const appealJuror = []\n    const appealRulings = []\n\n    for (let appeal = 0; appeal <= dispute.numberOfAppeals; appeal++) {\n      const isLastAppeal = dispute.firstSession + appeal === lastSession\n      // Get appeal data\n      const draws = appealDraws[appeal] || []\n      let canRule = false\n      let canRepartition = false\n      let canExecute = false\n      let ruling\n      const rulingPromises = [\n        this._ArbitratorInstance.currentRulingForDispute(disputeID, appeal)\n      ]\n\n      // Extra info for the last appeal\n      if (isLastAppeal) {\n        if (draws.length > 0)\n          rulingPromises.push(\n            this._ArbitratorInstance.canRuleDispute(disputeID, draws, account)\n          )\n\n        if (session && period)\n          canRepartition =\n            lastSession <= session && // Not appealed to the next session\n            period === arbitratorConstants.PERIOD.EXECUTE && // Executable period\n            dispute.state === disputeConstants.STATE.OPEN // Open dispute\n        canExecute = dispute.state === disputeConstants.STATE.EXECUTABLE // Executable state\n      }\n\n      // Wait for parallel requests to complete\n      ;[ruling, canRule] = await Promise.all(rulingPromises)\n\n      let jurorRuling = null\n      // if can't rule that means they already did or they missed it\n      if (!canRule) {\n        jurorRuling = await this._ArbitratorInstance.getVoteForJuror(\n          dispute.disputeID,\n          appeal,\n          account\n        )\n      }\n\n      const appealCreatedAt = await this.getAppealCreatedAt(\n        dispute.disputeID,\n        account,\n        appeal\n      )\n      const appealDeadline = await this.getDisputeDeadline(\n        dispute.disputeID,\n        appeal\n      )\n      const appealRuledAt = await this.getAppealRuledAt(\n        dispute.disputeID,\n        appeal\n      )\n\n      appealJuror[appeal] = {\n        createdAt: appealCreatedAt,\n        fee: dispute.arbitrationFeePerJuror.mul(draws.length),\n        draws,\n        jurorRuling,\n        canRule\n      }\n      appealRulings[appeal] = {\n        voteCounter: dispute.voteCounters[appeal],\n        deadline: appealDeadline,\n        ruledAt: appealRuledAt,\n        ruling,\n        canRepartition,\n        canExecute\n      }\n    }\n\n    return {\n      // Arbitrable Contract Data\n      arbitrableContractAddress,\n      arbitratorAddress,\n      parties,\n      evidence,\n      metaEvidence,\n\n      // Dispute Data\n      disputeID,\n      firstSession: dispute.firstSession,\n      lastSession,\n      numberOfAppeals: dispute.numberOfAppeals,\n      disputeState: dispute.state,\n      disputeStatus: dispute.status,\n      appealJuror,\n      appealRulings,\n      netPNK\n    }\n  }\n}\n\nexport default Disputes\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/Disputes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 247,
    "kind": "class",
    "name": "Disputes",
    "memberof": "src/resources/Disputes.js",
    "static": true,
    "longname": "src/resources/Disputes.js~Disputes",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/resources/Disputes.js",
    "importStyle": "Disputes",
    "description": "Disputes API. Provides cross arbitrator and arbitrable contracts functionality.\nRequires Store Provider to be set.",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 248,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/resources/Disputes.js~Disputes",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true
  },
  {
    "__docId__": 249,
    "kind": "member",
    "name": "_ArbitratorInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_ArbitratorInstance",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "member",
    "name": "_ArbitrableInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_ArbitrableInstance",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "member",
    "name": "_StoreProviderInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_StoreProviderInstance",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 252,
    "kind": "member",
    "name": "disputeCache",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#disputeCache",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 253,
    "kind": "member",
    "name": "setArbitratorInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#setArbitratorInstance",
    "access": "public",
    "description": "Set arbitrator instance.",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorInstance",
        "description": "instance of an arbitrator contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "setArbitrableInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#setArbitrableInstance",
    "access": "public",
    "description": "Set arbitrable instance.",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableInstance",
        "description": "instance of an arbitrable contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "member",
    "name": "registerStoreUpdateEventListeners",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#registerStoreUpdateEventListeners",
    "access": "public",
    "description": "Method to register all dispute handlers to an EventListener.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "eventListener",
        "description": "The EventListener instance. See utils/EventListener.js."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "member",
    "name": "_storeNewDisputeHandler",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_storeNewDisputeHandler",
    "access": "private",
    "description": "Event listener handler that stores dispute in store upon creation",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Account of user to update store data for"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "member",
    "name": "_updateDisputeCache",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_updateDisputeCache",
    "access": "private",
    "description": "Add new data to the cache",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute. Used as the key in cache"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "newCacheData",
        "description": "Freeform data to cache. Will overwrite data with the same keys."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "member",
    "name": "_getDisputeStartBlock",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#_getDisputeStartBlock",
    "access": "private",
    "description": "Get the block at which a dispute was created. Used to find timestamps for dispute.\nThe start block is cached after it has been found once as it will never change.",
    "lineNumber": 134,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The block number that the dispute was created."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The address of the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The block number that the dispute was created."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "member",
    "name": "getDisputeFromStore",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#getDisputeFromStore",
    "access": "public",
    "description": "Fetch the shared dispute data from the store.",
    "lineNumber": 178,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} The dispute data in the store."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The users account."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The dispute data in the store."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "member",
    "name": "getDisputeDeadline",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#getDisputeDeadline",
    "access": "public",
    "description": "Get the dispute deadline for the appeal.",
    "lineNumber": 193,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} timestamp of the appeal"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "The appeal number. 0 if there have been no appeals."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "timestamp of the appeal"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "member",
    "name": "getAppealRuledAt",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#getAppealRuledAt",
    "access": "public",
    "description": "Get the timestamp on when the dispute's ruling was finalized.",
    "lineNumber": 222,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} timestamp of the appeal"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "The appeal number. 0 if there have been no appeals."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "timestamp of the appeal"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "member",
    "name": "getAppealCreatedAt",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#getAppealCreatedAt",
    "access": "public",
    "description": "Get the timestamp on when the dispute's appeal was created",
    "lineNumber": 255,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} timestamp of the appeal"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The users address."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "The appeal number. 0 if there have been no appeals."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "timestamp of the appeal"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 267,
    "kind": "member",
    "name": "getDataForDispute",
    "memberof": "src/resources/Disputes.js~Disputes",
    "static": false,
    "longname": "src/resources/Disputes.js~Disputes#getDataForDispute",
    "access": "public",
    "description": "Get data for a dispute. This method provides data from the store as well as both\narbitrator and arbitrable contracts. Used to get all relevant data on a dispute.",
    "lineNumber": 301,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Data object for the dispute that uses data from the contract and the store."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The dispute's ID."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The juror's address."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Data object for the dispute that uses data from the contract and the store."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 268,
    "kind": "file",
    "name": "src/resources/Notifications.js",
    "content": "import _ from 'lodash'\n\nimport * as arbitratorConstants from '../constants/arbitrator'\nimport * as notificationConstants from '../constants/notification'\nimport * as disputeConstants from '../constants/dispute'\nimport { MISSING_STORE_PROVIDER } from '../constants/error'\nimport isRequired from '../utils/isRequired'\n\n/**\n * Notifications API. Use this object to fetch notifications from the store, register\n * event log handlers to update store and send push notifications.\n */\nclass Notifications {\n  constructor(\n    arbitratorInstance = isRequired('arbitratorInstance'),\n    arbitrableInstance = isRequired('arbitrableInstance'),\n    storeProviderInstance\n  ) {\n    this._ArbitratorInstance = arbitratorInstance\n    this._Web3Wrapper = this._ArbitratorInstance.getWeb3Wrapper()\n    this._ArbitrableInstance = arbitrableInstance\n    this._StoreProviderInstance = storeProviderInstance\n  }\n  /**\n   * Set arbitrator instance.\n   * @param {object} arbitratorInstance - instance of an arbitrator contract.\n   */\n  setArbitratorInstance = arbitratorInstance => {\n    this._ArbitratorInstance = arbitratorInstance\n  }\n  /**\n   * Set arbitrable instance.\n   * @param {object} arbitrableInstance - instance of an arbitrable contract.\n   */\n  setArbitrableInstance = arbitrableInstance => {\n    this._ArbitrableInstance = arbitrableInstance\n  }\n  /**\n   * Set store provider instance.\n   * @param {object} storeProviderInstance - instance of store provider wrapper.\n   */\n  setStoreProviderInstance = storeProviderInstance => {\n    this._StoreProviderInstance = storeProviderInstance\n  }\n\n  // **************************** //\n  // *         Public           * //\n  // **************************** //\n\n  /**\n   * Register event handlers for the arbitrator instance.\n   * @param {string} account - Filter notifications for account.\n   * @param {object} eventListener - Event Listener that will fetch logs and call callbacks\n   * @param {function} callback - If we want notifications to be \"pushed\" provide a callback function to call when a new notification is created.\n   */\n  registerArbitratorNotifications = (\n    account = isRequired('account'),\n    eventListener = isRequired('eventListener'),\n    callback\n  ) => {\n    const eventHandlerMap = {\n      DisputeCreation: this._disputeCreationHandler,\n      AppealPossible: this._appealPossibleHandler,\n      AppealDecision: this._appealingDecisionHandler,\n      TokenShift: this._tokenShiftHandler,\n      ArbitrationReward: this._arbitrationRewardHandler,\n      NewPeriod: this._newPeriodHandler\n    }\n\n    for (let event in eventHandlerMap) {\n      if (eventHandlerMap.hasOwnProperty(event)) {\n        eventListener.addEventHandler(\n          this._ArbitratorInstance,\n          event,\n          this._createHandler(eventHandlerMap[event], account, callback)\n        )\n      }\n    }\n  }\n\n  /**\n   * Get stateful notifications. Stateful notifications change based on the state of the arbitrator contract.\n   * @param {string} account - Filter notifications for account.\n   * @param {function} isJuror - If the account is a juror.\n   * @returns {object[]} - Array of stateful notification objects.\n   */\n  getStatefulNotifications = async (account, isJuror = true) => {\n    const notifications = []\n    const [contracts, disputes] = await Promise.all([\n      this._getContracts(account),\n      this._getDisputes(account, isJuror)\n    ])\n    const currentPeriod = await this._ArbitratorInstance.getPeriod()\n    const currentSession = await this._ArbitratorInstance.getSession()\n    if (isJuror) {\n      /* Juror notifications:\n      * - Activate tokens\n      * - Need to vote\n      * - Ready to repartition (shared)\n      * - Ready to execute (shared)\n      */\n      if (currentPeriod === arbitratorConstants.PERIOD.ACTIVATION) {\n        // FIXME use estimateGas\n        const contractInstance = await this._ArbitratorInstance.loadContract()\n        const lastActivatedSession = (await contractInstance.jurors(\n          account\n        ))[2].toNumber()\n        if (lastActivatedSession < currentSession) {\n          notifications.push(\n            this._createNotification(\n              notificationConstants.TYPE.CAN_ACTIVATE,\n              'You can now deposit PNK.',\n              {}\n            )\n          )\n        }\n      } else if (currentPeriod === arbitratorConstants.PERIOD.VOTE) {\n        for (let dispute of disputes) {\n          const draws = dispute.appealDraws[dispute.appealDraws.length - 1]\n          if (draws) {\n            const canVote = await this._ArbitratorInstance.canRuleDispute(\n              dispute.disputeID,\n              draws,\n              account\n            )\n            if (canVote) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_VOTE,\n                  'Open cases still need your decision.',\n                  {\n                    disputeID: dispute.disputeID,\n                    arbitratorAddress: dispute.arbitratorAddress\n                  }\n                )\n              )\n            }\n          }\n        }\n      }\n    } else {\n      /* Counterparty notifications:\n      * - Need to pay fee\n      * - Ready to repartition (shared)\n      * - Ready to execute (shared)\n      */\n      await Promise.all(\n        contracts.map(async contract => {\n          // load arbitrable contract\n          await this._ArbitrableInstance.setContractInstance(contract.address)\n          const contractData = await this._ArbitrableInstance.getData(\n            contract.partyA\n          )\n          const arbitrationCost = await this._ArbitratorInstance.getArbitrationCost(\n            contractData.arbitratorExtraData\n          )\n          if (contractData.partyA === account) {\n            if (contractData.partyAFee < arbitrationCost) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_PAY_FEE,\n                  'Arbitration fee required',\n                  {\n                    arbitratorAddress: contractData.arbitrator,\n                    arbitrableContractAddress: contract.address,\n                    feeToPay: arbitrationCost - contractData.partyAFee\n                  }\n                )\n              )\n            }\n          } else if (contractData.partyB === account) {\n            if (contractData.partyBFee < arbitrationCost) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_PAY_FEE,\n                  'Arbitration fee required',\n                  {\n                    arbitratorAddress: contractData.arbitrator,\n                    arbitrableContractAddress: contract.address,\n                    feeToPay: arbitrationCost - contractData.partyBFee\n                  }\n                )\n              )\n            }\n          }\n        })\n      )\n    }\n\n    // Repartition and execute\n    if (currentPeriod === arbitratorConstants.PERIOD.EXECUTE) {\n      await Promise.all(\n        disputes.map(async dispute => {\n          const disputeData = await this._ArbitratorInstance.getDispute(\n            dispute.disputeID\n          )\n          if (\n            disputeData.firstSession + disputeData.numberOfAppeals ===\n            currentSession\n          ) {\n            if (disputeData.state <= disputeConstants.STATE.RESOLVING) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_REPARTITION,\n                  'Ready to repartition dispute',\n                  {\n                    disputeID: dispute.disputeID,\n                    arbitratorAddress: dispute.arbitratorAddress\n                  }\n                )\n              )\n            } else if (\n              disputeData.state === disputeConstants.STATE.EXECUTABLE\n            ) {\n              notifications.push(\n                this._createNotification(\n                  notificationConstants.TYPE.CAN_EXECUTE,\n                  'Ready to execute dispute',\n                  {\n                    disputeID: dispute.disputeID,\n                    arbitratorAddress: dispute.arbitratorAddress\n                  }\n                )\n              )\n            }\n          }\n        })\n      )\n    }\n    return notifications\n  }\n\n  /**\n   * Fetch all unread notifications from store.\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Array of notification objects.\n   */\n  getUnreadStoredNotifications = async account => {\n    this._requireStoreProvider()\n    const profile = await this._StoreProviderInstance.newUserProfile(account)\n    const currentArbitrator = this._ArbitratorInstance.getContractAddress()\n    // return notifications that are for current arbitrator and are unread\n    return _.filter(\n      profile.notifications,\n      notification =>\n        notification.data.arbitratorAddress === currentArbitrator &&\n        !notification.read\n    )\n  }\n\n  /**\n   * Mark stored notification as read.\n   * @param {string} account address of user\n   * @param {string} txHash hash of transaction that produced event\n   * @param {number} logIndex index of the log. used to differentiate logs if multiple logs per tx\n   * @returns {promise} promise that can be waited on for syncronousity\n   */\n  markStoredNotificationAsRead = async (account, txHash, logIndex) => {\n    this._requireStoreProvider()\n    const result = await this._StoreProviderInstance.markNotificationAsRead(\n      account,\n      txHash,\n      logIndex,\n      true\n    )\n    return result\n  }\n\n  /**\n   * Fetch all user notifications from store.\n   * @param {string} account - Address of user.\n   * @returns {object[]} - Array of notification objects.\n   */\n  getStoredNotifications = async account => {\n    this._requireStoreProvider()\n\n    return (await this._StoreProviderInstance.getUserProfile(account))\n      .notifications\n  }\n\n  // **************************** //\n  // *        Handlers          * //\n  // **************************** //\n\n  /**\n   * Checks for appeal possible notifications during APPEAL period.\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _newPeriodHandler = async (event, account, callback) => {\n    const newPeriod = event.args._period.toNumber()\n    const eventSession = event.args._session.toNumber()\n    const currentSession = await this._ArbitratorInstance.getSession()\n    // send appeal possible notifications if in current session\n    if (\n      newPeriod === arbitratorConstants.PERIOD.APPEAL &&\n      eventSession === currentSession\n    ) {\n      const disputes = await this._getDisputes(account) // get users disputes\n      const openDisputes = await this._ArbitratorInstance.getOpenDisputesForSession() // get all disputes for session\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n      await Promise.all(\n        openDisputes.map(async openDispute => {\n          if (\n            _.findIndex(\n              disputes,\n              dispute =>\n                dispute.disputeID === openDispute.disputeID &&\n                dispute.arbitratorAddress === arbitratorAddress\n            ) >= 0\n          ) {\n            const ruling = await this._ArbitratorInstance.currentRulingForDispute(\n              openDispute.disputeID,\n              openDispute.numberOfAppeals\n            )\n\n            const notification = await this._newNotification(\n              account,\n              event.transactionHash,\n              event.blockNumber,\n              openDispute.disputeID, // use disputeID instead of logIndex since it doens't have its own event\n              notificationConstants.TYPE.APPEAL_POSSIBLE,\n              'A ruling has been made. Appeal is possible',\n              {\n                disputeID: openDispute.disputeID,\n                arbitratorAddress,\n                ruling\n              }\n            )\n\n            await this._sendPushNotification(callback, notification)\n          }\n        })\n      )\n    }\n  }\n\n  /**\n   * Handler for DisputeCreation event\n   * sends notification to partyA and partyB when dispute is created\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _disputeCreationHandler = async (event, account, callback) => {\n    const disputeID = event.args._disputeID.toNumber()\n    const txHash = event.transactionHash\n    // load arbitrable contract\n    await this._ArbitrableInstance.setContractInstance(event.args._arbitrable)\n\n    const arbitrableData = await this._ArbitrableInstance.getData()\n\n    if (\n      arbitrableData.partyA === account ||\n      arbitrableData.partyB === account\n    ) {\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n      const notification = await this._newNotification(\n        account,\n        txHash,\n        event.blockNumber,\n        event.logIndex,\n        notificationConstants.TYPE.DISPUTE_CREATED,\n        'New Dispute Created',\n        {\n          disputeID: disputeID,\n          arbitratorAddress: arbitratorAddress\n        }\n      )\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * handler for AppealPossible event\n   * sends notification informing accounts that a ruling has been made and an appeal possible\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _appealPossibleHandler = async (event, account, callback) => {\n    const disputes = await this._getDisputes(account)\n    const disputeID = event.args._disputeID.toNumber()\n    const ruling = await this._ArbitratorInstance.currentRulingForDispute(\n      disputeID\n    )\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n    if (\n      _.findIndex(\n        disputes,\n        dispute =>\n          dispute.disputeID === disputeID &&\n          dispute.arbitratorAddress === arbitratorAddress\n      ) >= 0\n    ) {\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.blockNumber,\n        event.logIndex,\n        notificationConstants.TYPE.APPEAL_POSSIBLE,\n        'A ruling has been made. Appeal is possible',\n        {\n          disputeID,\n          arbitratorAddress,\n          ruling\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * Handler for AppealDecision event\n   * sends notification informing subscribers that a ruling has been appealed\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _appealingDecisionHandler = async (event, account, callback) => {\n    const disputes = await this._getDisputes(account)\n    const disputeID = event.args._disputeID.toNumber()\n    const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n\n    if (\n      _.findIndex(\n        disputes,\n        dispute =>\n          dispute.disputeID === disputeID &&\n          dispute.arbitratorAddress === arbitratorAddress\n      ) >= 0\n    ) {\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.blockNumber,\n        event.logIndex,\n        notificationConstants.TYPE.RULING_APPEALED,\n        'A ruling you made has been appealed by one of the parties.',\n        {\n          disputeID,\n          arbitratorAddress\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * Handler for TokenShift event.\n   * NOTE: you will get a notification for each vote. So a juror that has 3 votes will receive 3 notifications\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _tokenShiftHandler = async (event, account, callback) => {\n    // address indexed _account, uint _disputeID, int _amount\n    const disputeID = event.args._disputeID.toNumber()\n    const address = event.args._account\n    const amount = event.args._amount.toString()\n\n    if (account === address) {\n      const message =\n        amount === 0\n          ? `Dispute Resolved: No PNK won`\n          : `Dispute Resolved: You have ${\n              amount < 0 ? 'lost' : 'won'\n            } ${this._Web3Wrapper.fromWei(amount, 'ether')} PNK.`\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.blockNumber,\n        event.logIndex,\n        notificationConstants.TYPE.TOKEN_SHIFT,\n        message,\n        {\n          disputeID,\n          arbitratorAddress,\n          account: address,\n          amount\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  /**\n   * Handler for arbitration reward event.\n   * @param {object} event - The event log.\n   * @param {string} account - The user account.\n   * @param {function} callback - The callback.\n   */\n  _arbitrationRewardHandler = async (event, account, callback) => {\n    // address indexed _account, uint _disputeID, int _amount\n    const disputeID = event.args._disputeID.toNumber()\n    const address = event.args._account\n    const amount = event.args._amount.toString()\n\n    if (account === address) {\n      const arbitratorAddress = this._ArbitratorInstance.getContractAddress()\n      const notification = await this._newNotification(\n        account,\n        event.transactionHash,\n        event.blockNumber,\n        event.logIndex,\n        notificationConstants.TYPE.ARBITRATION_REWARD,\n        `You have been awarded an ${this._Web3Wrapper.fromWei(\n          amount,\n          'ether'\n        )} ETH arbitration fee`,\n        {\n          disputeID,\n          arbitratorAddress,\n          account: address,\n          amount\n        }\n      )\n\n      if (notification) await this._sendPushNotification(callback, notification)\n    }\n  }\n\n  // **************************** //\n  // *        Helpers           * //\n  // **************************** //\n  /**\n   * Helper method to create handler with correct params\n   * @param {function} handler - The handler.\n   * @param {string} account - The account.\n   * @param {function} callback - The callback.\n   * @returns {object} - The created handler.\n   */\n  _createHandler = (handler, account, callback) => args =>\n    handler(args, account, callback)\n\n  /**\n   * Sends a push notification.\n   * @param {function} callback - The callback.\n   * @param {object} notification - The notification.\n   */\n  _sendPushNotification = async (callback, notification) => {\n    if (callback && notification) {\n      callback(notification)\n    }\n  }\n\n  /**\n   * Creates a notification object.\n   * @param {number} notificationType - The notificationType.\n   * @param {string} message - The message.\n   * @param {object} data - The data.\n   * @returns {function} - The notification object.\n   */\n  _createNotification = (notificationType, message, data) => ({\n    notificationType,\n    message,\n    data\n  })\n\n  /**\n   * Creates a new notification object in the store.\n   * @param {string} account - The account.\n   * @param {string} txHash - The txHash.\n   * @param {string} blockNumber - The block number of the event log.\n   * @param {number} logIndex - The logIndex.\n   * @param {number} notificationType - The notificationType.\n   * @param {string} message - The message.\n   * @param {object} data - The data.\n   * @param {bool} read - Wether the notification has been read or not.\n   * @returns {function} - The notification object.\n   */\n  _newNotification = async (\n    account,\n    txHash,\n    blockNumber,\n    logIndex,\n    notificationType,\n    message = '',\n    data = {},\n    read = false\n  ) => {\n    if (this._StoreProviderInstance) {\n      // update last block we have processed an event for\n      await this._StoreProviderInstance.updateLastBlock(account, blockNumber)\n\n      const response = await this._StoreProviderInstance.newNotification(\n        account,\n        txHash,\n        logIndex,\n        notificationType,\n        message,\n        data,\n        read\n      )\n\n      if (response.status === 201) {\n        const notification = response.body.notifications.filter(\n          notification =>\n            notification.txHash === txHash && notification.logIndex === logIndex\n        )\n        return notification[0]\n      }\n    } else {\n      // If we have no store provider simply return object of params for a push notification\n      return {\n        txHash,\n        logIndex,\n        notificationType,\n        message,\n        data,\n        read\n      }\n    }\n  }\n\n  /**\n   * Get contracts from store if set or return empty array. Used for notifications\n   * @param {string} account - Filter notifications for account.\n   * @returns {object[]} - Array of dispute objects\n   */\n  _getContracts = async account => {\n    let contracts = []\n\n    // If we have store provider fetch contracts and disputes from the store.\n    if (this._StoreProviderInstance) {\n      const userProfile = await this._StoreProviderInstance.newUserProfile(\n        account\n      )\n\n      contracts = userProfile.contracts\n    }\n\n    return contracts\n  }\n\n  /**\n   * Get disputes either from store or from arbitrator if Store Provider is not set. Used for notifications\n   * @param {string} account - Filter notifications for account.\n   * @param {function} isJuror - If the account is a juror.\n   * @returns {object[]} - Array of dispute objects\n   */\n  _getDisputes = async (account, isJuror = true) => {\n    let disputes = []\n\n    // If we have store provider fetch contracts and disputes from the store.\n    if (this._StoreProviderInstance) {\n      disputes = await this._StoreProviderInstance.getDisputes(account)\n    } else if (isJuror) {\n      // We have no way to get contracts. Get disputes from current session\n      // TODO make a function to get open disputes for parites\n      disputes = await this._ArbitratorInstance.getDisputesForJuror(account)\n    }\n\n    return disputes\n  }\n\n  _requireStoreProvider = () => {\n    if (!this._StoreProviderInstance) throw new Error(MISSING_STORE_PROVIDER)\n  }\n}\n\nexport default Notifications\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/Notifications.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 269,
    "kind": "class",
    "name": "Notifications",
    "memberof": "src/resources/Notifications.js",
    "static": true,
    "longname": "src/resources/Notifications.js~Notifications",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/resources/Notifications.js",
    "importStyle": "Notifications",
    "description": "Notifications API. Use this object to fetch notifications from the store, register\nevent log handlers to update store and send push notifications.",
    "lineNumber": 13,
    "interface": false
  },
  {
    "__docId__": 270,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/resources/Notifications.js~Notifications",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true
  },
  {
    "__docId__": 271,
    "kind": "member",
    "name": "_ArbitratorInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_ArbitratorInstance",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "member",
    "name": "_Web3Wrapper",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_Web3Wrapper",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 273,
    "kind": "member",
    "name": "_ArbitrableInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_ArbitrableInstance",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "_StoreProviderInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_StoreProviderInstance",
    "access": "private",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "member",
    "name": "setArbitratorInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#setArbitratorInstance",
    "access": "public",
    "description": "Set arbitrator instance.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorInstance",
        "description": "instance of an arbitrator contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "member",
    "name": "setArbitrableInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#setArbitrableInstance",
    "access": "public",
    "description": "Set arbitrable instance.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableInstance",
        "description": "instance of an arbitrable contract."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "member",
    "name": "setStoreProviderInstance",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#setStoreProviderInstance",
    "access": "public",
    "description": "Set store provider instance.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderInstance",
        "description": "instance of store provider wrapper."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "member",
    "name": "registerArbitratorNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#registerArbitratorNotifications",
    "access": "public",
    "description": "Register event handlers for the arbitrator instance.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "eventListener",
        "description": "Event Listener that will fetch logs and call callbacks"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "If we want notifications to be \"pushed\" provide a callback function to call when a new notification is created."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "member",
    "name": "getStatefulNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#getStatefulNotifications",
    "access": "public",
    "description": "Get stateful notifications. Stateful notifications change based on the state of the arbitrator contract.",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of stateful notification objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "isJuror",
        "description": "If the account is a juror."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of stateful notification objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "member",
    "name": "getUnreadStoredNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#getUnreadStoredNotifications",
    "access": "public",
    "description": "Fetch all unread notifications from store.",
    "lineNumber": 238,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of notification objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of notification objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "member",
    "name": "markStoredNotificationAsRead",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#markStoredNotificationAsRead",
    "access": "public",
    "description": "Mark stored notification as read.",
    "lineNumber": 258,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{promise} promise that can be waited on for syncronousity"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "address of user"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "hash of transaction that produced event"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "index of the log. used to differentiate logs if multiple logs per tx"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "promise"
      ],
      "spread": false,
      "description": "promise that can be waited on for syncronousity"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "member",
    "name": "getStoredNotifications",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#getStoredNotifications",
    "access": "public",
    "description": "Fetch all user notifications from store.",
    "lineNumber": 274,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of notification objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of notification objects."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "member",
    "name": "_newPeriodHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_newPeriodHandler",
    "access": "private",
    "description": "Checks for appeal possible notifications during APPEAL period.",
    "lineNumber": 291,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "member",
    "name": "_disputeCreationHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_disputeCreationHandler",
    "access": "private",
    "description": "Handler for DisputeCreation event\nsends notification to partyA and partyB when dispute is created",
    "lineNumber": 347,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "member",
    "name": "_appealPossibleHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_appealPossibleHandler",
    "access": "private",
    "description": "handler for AppealPossible event\nsends notification informing accounts that a ruling has been made and an appeal possible",
    "lineNumber": 383,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "member",
    "name": "_appealingDecisionHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_appealingDecisionHandler",
    "access": "private",
    "description": "Handler for AppealDecision event\nsends notification informing subscribers that a ruling has been appealed",
    "lineNumber": 424,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "member",
    "name": "_tokenShiftHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_tokenShiftHandler",
    "access": "private",
    "description": "Handler for TokenShift event.\nNOTE: you will get a notification for each vote. So a juror that has 3 votes will receive 3 notifications",
    "lineNumber": 461,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "member",
    "name": "_arbitrationRewardHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_arbitrationRewardHandler",
    "access": "private",
    "description": "Handler for arbitration reward event.",
    "lineNumber": 500,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event log."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The user account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "member",
    "name": "_createHandler",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_createHandler",
    "access": "private",
    "description": "Helper method to create handler with correct params",
    "lineNumber": 540,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The created handler."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "The handler."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The created handler."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "member",
    "name": "_sendPushNotification",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_sendPushNotification",
    "access": "private",
    "description": "Sends a push notification.",
    "lineNumber": 548,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "notification",
        "description": "The notification."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "member",
    "name": "_createNotification",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_createNotification",
    "access": "private",
    "description": "Creates a notification object.",
    "lineNumber": 561,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function} - The notification object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "notificationType",
        "description": "The notificationType."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": "The notification object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "_newNotification",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_newNotification",
    "access": "private",
    "description": "Creates a new notification object in the store.",
    "lineNumber": 579,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{function} - The notification object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "The txHash."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "blockNumber",
        "description": "The block number of the event log."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "The logIndex."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "notificationType",
        "description": "The notificationType."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data."
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "read",
        "description": "Wether the notification has been read or not."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": "The notification object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "member",
    "name": "_getContracts",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_getContracts",
    "access": "private",
    "description": "Get contracts from store if set or return empty array. Used for notifications",
    "lineNumber": 628,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of dispute objects"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of dispute objects"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "member",
    "name": "_getDisputes",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_getDisputes",
    "access": "private",
    "description": "Get disputes either from store or from arbitrator if Store Provider is not set. Used for notifications",
    "lineNumber": 649,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object[]} - Array of dispute objects"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "Filter notifications for account."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "isJuror",
        "description": "If the account is a juror."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object[]"
      ],
      "spread": false,
      "description": "Array of dispute objects"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "member",
    "name": "_requireStoreProvider",
    "memberof": "src/resources/Notifications.js~Notifications",
    "static": false,
    "longname": "src/resources/Notifications.js~Notifications#_requireStoreProvider",
    "access": "private",
    "description": null,
    "lineNumber": 664,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "file",
    "name": "src/resources/index.js",
    "content": "import Disputes from './Disputes'\nimport Notifications from './Notifications'\nimport Auth from './Auth'\n\nexport { Disputes, Notifications, Auth }\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/resources/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "file",
    "name": "src/utils/EventListener.js",
    "content": "import _ from 'lodash'\n\nimport PromiseQueue from '../utils/PromiseQueue'\nimport isRequired from '../utils/isRequired'\nimport * as errorConstants from '../constants/error'\n\n/**\n * EventListener is used to watch events on the blockchain for a set of contracts.\n * Handlers for specific events can be added. When an event log is found EventListener\n * will fire all handlers registered for the contract.\n */\nclass EventListener {\n  /**\n   * Listen for events in contract and handles callbacks with registered event handlers.\n   * @param {object[]} _contractImplementations - Contract Implementation instances to fetch event logs for.\n   */\n  constructor(_contractImplementations = []) {\n    this.contractInstances = []\n    // map address -> { event: [handlers], ... }\n    this.contractEventHandlerMap = {}\n    // map address -> watcher instance\n    this.watcherInstances = {}\n    // event handler queue\n    this.eventHandlerQueue = new PromiseQueue()\n    // initialize class variables for new contract instances\n    _contractImplementations.forEach(instance => {\n      this.addContractImplementation(instance)\n    })\n  }\n\n  /**\n   * Fetch all logs from contractInstance in a block range.\n   * @param {object} contractImplementationInstance - Contract Implementation instance.\n   * @param {number} firstBlock - Lower bound of search range.\n   * @param {number} lastBlock - Upper bound of search range.\n   * @returns {Promise} All events in block range.\n   */\n  static getAllEventLogs = async (\n    contractImplementationInstance = isRequired(\n      'contractImplementationInstance'\n    ),\n    firstBlock = 0,\n    lastBlock = 'latest'\n  ) =>\n    Promise.all(\n      (await contractImplementationInstance.loadContract())\n        .allEvents({\n          fromBlock: firstBlock,\n          toBlock: lastBlock\n        })\n        .get((error, result) => {\n          if (error)\n            throw new Error(errorConstants.ERROR_FETCHING_EVENTS(error))\n\n          return result\n        })\n    )\n\n  /**\n   * Fetch logs from contractInstance for a specific event in a block range.\n   * @param {object} contractImplementationInstance - contract Implementation instance.\n   * @param {string} eventName - Name of the event.\n   * @param {number} firstBlock - Lower bound of search range.\n   * @param {number} lastBlock - Upper bound of search range.\n   * @param {object} filters - Extra filters\n   * @returns {Promise} All events in block range.\n   */\n  static getEventLogs = async (\n    contractImplementationInstance = isRequired(\n      'contractImplementationInstance'\n    ),\n    eventName = isRequired('eventName'),\n    firstBlock = 0,\n    lastBlock = 'latest',\n    filters = {}\n  ) => {\n    await contractImplementationInstance.loadContract()\n    return new Promise((resolve, reject) => {\n      contractImplementationInstance.contractInstance[eventName](filters, {\n        fromBlock: firstBlock,\n        toBlock: lastBlock\n      }).get((error, result) => {\n        if (error) reject(errorConstants.ERROR_FETCHING_EVENTS(error))\n\n        resolve(result)\n      })\n    })\n  }\n\n  /**\n   * Add a contract instance to watch for new event logs.\n   * @param {object} contractImplementationInstance - Contract Implementation instance\n   */\n  addContractImplementation = contractImplementationInstance => {\n    this.contractInstances.push(contractImplementationInstance)\n    this.contractEventHandlerMap[\n      contractImplementationInstance.getContractAddress()\n    ] = {}\n  }\n\n  /**\n   * Remove contract instance being watched. Will also remove all handlers.\n   * @param {string} contractImplementationInstance - contract implementation instance\n   */\n  removeContractInstance = (\n    contractImplementationInstance = isRequired(\n      'contractImplementationInstance'\n    )\n  ) => {\n    const contractAddress = contractImplementationInstance.getContractAddress()\n    // remove instance from this.contractInstances\n    const removedInstance = _.remove(\n      this.contractInstances,\n      instance => instance.getContractAddress() === contractAddress\n    )\n    // if we didn't remove anything throw error\n    if (removedInstance.length === 0)\n      throw new Error(errorConstants.MISSING_CONTRACT_INSTANCE(contractAddress))\n    // stop watching on these instances\n    removedInstance.forEach(instance => this.stopWatchingForEvents(instance))\n\n    // remove handlers for contract instance\n    delete this.contractEventHandlerMap[contractAddress]\n  }\n\n  /**\n   * Add event handler that will be called when event log is found.\n   * @param {string} contractImplementationInstance - Contract implementation instance\n   * @param {string} eventName - Name of event.\n   * @param {function} handler - Function to be called when event is consumed.\n   */\n  addEventHandler = (\n    contractImplementationInstance = isRequired('contractAddress'),\n    eventName = isRequired('eventName'),\n    handler = isRequired('handler')\n  ) => {\n    const contractAddress = contractImplementationInstance.getContractAddress()\n    if (!this.contractEventHandlerMap[contractAddress][eventName])\n      this.contractEventHandlerMap[contractAddress][eventName] = []\n    this.contractEventHandlerMap[contractAddress][eventName].push(handler)\n  }\n\n  /**\n   * Watch for events on all contract instances. Call registered handlers when logs are found.\n   * @param {number} fromBlock - A block number can be passed to catch up on missed logs\n   * @returns {Promise} - Promise resolves when all watchers have been started\n   */\n  watchForEvents = async (fromBlock = 'latest') =>\n    Promise.all(\n      this.contractInstances.map(async contractImplementation => {\n        const instance = await contractImplementation.loadContract()\n        const newWatcherInstance = instance.allEvents({\n          fromBlock: fromBlock,\n          lastBlock: 'latest'\n        })\n\n        // NOTE: should we allow more than one listener per contract instance?\n        if (this.watcherInstances[instance.address])\n          this.watcherInstances[instance.address].stopWatching()\n\n        this.watcherInstances[instance.address] = newWatcherInstance\n        newWatcherInstance.watch((error, result) => {\n          if (!error) {\n            const handlers = this.contractEventHandlerMap[instance.address][\n              result.event\n            ]\n            if (handlers) {\n              handlers.forEach(handler => {\n                this._queueEvent(handler, result)\n              })\n            }\n          }\n        })\n      })\n    )\n\n  /**\n   * Stop listening on contract. If no contractAddress supplied it stops all listeners.\n   * @param {string} contractImplementationInstance - Address of the contract to stop watching\n   */\n  stopWatchingForEvents = contractImplementationInstance => {\n    if (contractImplementationInstance) {\n      const watcherInstance = this.watcherInstances[\n        contractImplementationInstance.getContractAddress()\n      ]\n\n      if (watcherInstance) watcherInstance.stopWatching()\n    } else\n      this.contractInstances.forEach(instance => {\n        this.watcherInstances[instance.getContractAddress()].stopWatching()\n      })\n  }\n\n  /**\n   * Queues an event.\n   * @param {function} handler - The handler.\n   * @param {object} event - The event.\n   */\n  _queueEvent = async (handler, event) => {\n    const eventTask = async () => {\n      await handler(event)\n    }\n\n    this.eventHandlerQueue.push(eventTask)\n  }\n}\n\nexport default EventListener\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/EventListener.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 301,
    "kind": "class",
    "name": "EventListener",
    "memberof": "src/utils/EventListener.js",
    "static": true,
    "longname": "src/utils/EventListener.js~EventListener",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/EventListener.js",
    "importStyle": "EventListener",
    "description": "EventListener is used to watch events on the blockchain for a set of contracts.\nHandlers for specific events can be added. When an event log is found EventListener\nwill fire all handlers registered for the contract.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 302,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/EventListener.js~EventListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#constructor",
    "access": "public",
    "description": "Listen for events in contract and handles callbacks with registered event handlers.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "_contractImplementations",
        "description": "Contract Implementation instances to fetch event logs for."
      }
    ]
  },
  {
    "__docId__": 303,
    "kind": "member",
    "name": "contractInstances",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#contractInstances",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 304,
    "kind": "member",
    "name": "contractEventHandlerMap",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#contractEventHandlerMap",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "member",
    "name": "watcherInstances",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#watcherInstances",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "member",
    "name": "eventHandlerQueue",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#eventHandlerQueue",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 307,
    "kind": "member",
    "name": "getAllEventLogs",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": true,
    "longname": "src/utils/EventListener.js~EventListener.getAllEventLogs",
    "access": "public",
    "description": "Fetch all logs from contractInstance in a block range.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} All events in block range."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Contract Implementation instance."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "firstBlock",
        "description": "Lower bound of search range."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lastBlock",
        "description": "Upper bound of search range."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "All events in block range."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 308,
    "kind": "member",
    "name": "getEventLogs",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": true,
    "longname": "src/utils/EventListener.js~EventListener.getEventLogs",
    "access": "public",
    "description": "Fetch logs from contractInstance for a specific event in a block range.",
    "lineNumber": 68,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} All events in block range."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "contract Implementation instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventName",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "firstBlock",
        "description": "Lower bound of search range."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lastBlock",
        "description": "Upper bound of search range."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "filters",
        "description": "Extra filters"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "All events in block range."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 309,
    "kind": "member",
    "name": "addContractImplementation",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#addContractImplementation",
    "access": "public",
    "description": "Add a contract instance to watch for new event logs.",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Contract Implementation instance"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "member",
    "name": "removeContractInstance",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#removeContractInstance",
    "access": "public",
    "description": "Remove contract instance being watched. Will also remove all handlers.",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "contract implementation instance"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "member",
    "name": "addEventHandler",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#addEventHandler",
    "access": "public",
    "description": "Add event handler that will be called when event log is found.",
    "lineNumber": 132,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Contract implementation instance"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventName",
        "description": "Name of event."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Function to be called when event is consumed."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "member",
    "name": "watchForEvents",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#watchForEvents",
    "access": "public",
    "description": "Watch for events on all contract instances. Call registered handlers when logs are found.",
    "lineNumber": 148,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Promise resolves when all watchers have been started"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "fromBlock",
        "description": "A block number can be passed to catch up on missed logs"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise resolves when all watchers have been started"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "member",
    "name": "stopWatchingForEvents",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#stopWatchingForEvents",
    "access": "public",
    "description": "Stop listening on contract. If no contractAddress supplied it stops all listeners.",
    "lineNumber": 181,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractImplementationInstance",
        "description": "Address of the contract to stop watching"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "_queueEvent",
    "memberof": "src/utils/EventListener.js~EventListener",
    "static": false,
    "longname": "src/utils/EventListener.js~EventListener#_queueEvent",
    "access": "private",
    "description": "Queues an event.",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "The handler."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "event",
        "description": "The event."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "file",
    "name": "src/utils/PromiseQueue.js",
    "content": "/**\n * Chain promises so that they are evaluated in order.\n * @returns {object} - The promise queue object.\n */\nconst PromiseQueue = () => {\n  let promise = Promise.resolve()\n\n  return {\n    push: fn => {\n      promise = promise.then(fn, fn)\n    },\n    fetch: fn => {\n      let returnResolver\n      let returnRejecter\n      const returnPromise = new Promise((resolve, reject) => {\n        returnResolver = resolve\n        returnRejecter = reject\n      })\n      promise = promise\n        .then(fn, fn)\n        .then(res => returnResolver(res), err => returnRejecter(err))\n\n      return returnPromise\n    }\n  }\n}\n\nexport default PromiseQueue\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/PromiseQueue.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 316,
    "kind": "function",
    "name": "PromiseQueue",
    "memberof": "src/utils/PromiseQueue.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/PromiseQueue.js~PromiseQueue",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/PromiseQueue.js",
    "importStyle": "PromiseQueue",
    "description": "Chain promises so that they are evaluated in order.",
    "lineNumber": 5,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - The promise queue object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The promise queue object."
    },
    "params": []
  },
  {
    "__docId__": 317,
    "kind": "file",
    "name": "src/utils/StoreProviderWrapper.js",
    "content": "import _ from 'lodash'\n\nimport * as errorConstants from '../constants/error'\n\nimport PromiseQueue from './PromiseQueue'\nimport httpRequest from './httpRequest'\n\n/**\n * A wrapper for interacting with Kleros Store.\n */\nclass StoreProviderWrapper {\n  /**\n   * Create a new instance of StoreProviderWrapper.\n   * @param {string} storeProviderUri - The uri of kleros store.\n   */\n  constructor(storeProviderUri) {\n    this._storeUri = storeProviderUri\n    this._storeQueue = new PromiseQueue()\n    this._cachedProfiles = {}\n  }\n\n  /**\n   * use the queue for write request. this allows a function to be passed so we can read immediately before we write\n   * @param {fn} getBodyFn async function to call before we write. Should to reads and return JSON to be used as body.\n   * @param {string} verb POST or PUT\n   * @param {string} uri uri to call\n   * @param {string} userAddress The users ETH address. Used to clear cache.\n   * @returns {promise} promise that returns result of request. wait on this if you need it to be syncronous\n   */\n  queueWriteRequest = (getBodyFn, verb, uri = null, userAddress) => {\n    // Clear cache on write TODO update cache after every write\n    this._cachedProfiles[userAddress] = null\n\n    return this._storeQueue.fetch(() =>\n      getBodyFn().then(result => httpRequest(verb, uri, result))\n    )\n  }\n\n  /**\n   * If we know we are waiting on some other write before we want to read we can add a read request to the end of the queue.\n   * @param {string} uri uri to hit\n   * @returns {Promise} promise of the result function\n   */\n  queueReadRequest = uri =>\n    this._storeQueue.fetch(() => httpRequest('GET', uri))\n\n  getMetaEvidenceUri = (\n    userAddress,\n    contractAddress,\n    arbitrableTransactionIndex\n  ) =>\n    `${\n      this._storeUri\n    }/${userAddress}/contracts/${contractAddress}/arbitrable-transaction/${arbitrableTransactionIndex}/meta-evidence`\n\n  getEvidenceUri = (\n    userAddress,\n    contractAddress,\n    arbitrableTransactionIndex,\n    evidenceIndex\n  ) =>\n    `${\n      this._storeUri\n    }/${userAddress}/contracts/${contractAddress}/arbitrable-transaction/${arbitrableTransactionIndex}/evidence/${evidenceIndex}`\n\n  // **************************** //\n  // *          Read            * //\n  // **************************** //\n\n  /**\n   * Fetch stored user profile.\n   * @param {string} userAddress - Address of user.\n   * @returns {object} - a response object.\n   */\n  getUserProfile = async userAddress => {\n    const httpResponse = await httpRequest(\n      'GET',\n      `${this._storeUri}/${userAddress}`\n    )\n    this._cachedProfiles[userAddress] = httpResponse.body\n\n    return httpResponse.body\n  }\n\n  /**\n   * Fetch stored data on a contract for a user.\n   * @param {string} userAddress - Address of the user.\n   * @param {string} addressContract - The address of the contract.\n   * @returns {object} - Contact data.\n   */\n  getContractByAddress = async (userAddress, addressContract) => {\n    const userProfile = await this.getUserProfile(userAddress)\n    if (!userProfile) return {}\n\n    let contract = _.filter(\n      userProfile.contracts,\n      contract => contract.address === addressContract\n    )\n\n    return contract[0]\n  }\n\n  /**\n   * Get all stored data for a dispute. Must exist in User Profile.\n   * @param {string} userAddress - Address of user.\n   * @param {string} arbitratorAddress - Address of arbitrator contract.\n   * @param {number} disputeID - Index of the dispute.\n   * @returns {object} - a response object.\n   */\n  getDispute = async (userAddress, arbitratorAddress, disputeID) => {\n    const userProfile = await this.getUserProfile(userAddress)\n    if (!userProfile)\n      throw new Error(errorConstants.PROFILE_NOT_FOUND(userAddress))\n\n    const dispute = _.filter(\n      userProfile.disputes,\n      o =>\n        o.arbitratorAddress === arbitratorAddress && o.disputeId === disputeID\n    )[0]\n    dispute.disputeID = dispute.disputeId\n    return dispute\n  }\n\n  /**\n   * Fetch stored disputes for a user.\n   * @param {string} userAddress - Address of user.\n   * @returns {object} - a response object.\n   */\n  getDisputes = async userAddress => {\n    const userProfile = await this.getUserProfile(userAddress)\n    if (!userProfile) return []\n\n    return userProfile.disputes.map(dispute => {\n      dispute.disputeID = dispute.disputeId\n      return dispute\n    })\n  }\n\n  /**\n   * Fetch the last block seen for a user. This is commonly used with EventListerer.\n   * @param {string} userAddress - Address of user.\n   * @returns {number} The last block number.\n   */\n  getLastBlock = async userAddress => {\n    let userProfile\n    try {\n      userProfile = (await this.newUserProfile(userAddress)) || {}\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      userProfile = {}\n    }\n\n    return userProfile.lastBlock || 0\n  }\n\n  // **************************** //\n  // *          Write           * //\n  // **************************** //\n\n  /**\n   * Set up a new user profile if one does not exist.\n   * @param {string} userAddress - user's address\n   * @returns {object} - users existing or created profile\n   */\n  newUserProfile = async userAddress => {\n    let userProfile = await this.getUserProfile(userAddress)\n    if (_.isNull(userProfile)) {\n      // we can safely make request without queuing because all other writes for profile will fail if it hasn't been created.\n      const response = await httpRequest(\n        'POST',\n        `${this._storeUri}/${userAddress}`\n      )\n      userProfile = response.body\n    }\n\n    return userProfile\n  }\n\n  /**\n   * Update users last block seen. This is the only item in user profile that can be overwritten.\n   * @param {string} userAddress - User's address.\n   * @param {string} blockNumber - The newest block number seen by user.\n   * @returns {object} - HTTP response.\n   */\n  updateLastBlock = async (userAddress, blockNumber) => {\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            lastBlock: blockNumber\n          })\n        )\n      )\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/lastBlock`\n    )\n  }\n\n  /**\n   * Update users last processed session.\n   * @param {string} userAddress - User's address.\n   * @param {string} session - The current session that the user has processed\n   * @returns {object} - HTTP response.\n   */\n  updateUserSession = async (userAddress, session) => {\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            session\n          })\n        )\n      )\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/session`\n    )\n  }\n\n  /**\n   * Update the stored data on a contract for a user. Note that you cannot overwrite contract data.\n   * @param {string} userAddress - The user's address.\n   * @param {string} contractAddress - The address of the contract.\n   * @param {object} params - Params we want to update.\n   * @returns {Promise} - The resulting contract data.\n   */\n  updateContract = async (userAddress, contractAddress, params) => {\n    const getBodyFn = async () => {\n      let currentContractData = await this.getContractByAddress(\n        userAddress,\n        contractAddress\n      )\n      if (!currentContractData) currentContractData = {}\n      delete currentContractData._id\n\n      params.address = contractAddress\n\n      return JSON.stringify({ ...currentContractData, ...params })\n    }\n\n    const httpResponse = await this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/contracts/${contractAddress}`\n    )\n\n    return _.filter(\n      httpResponse.body[0].contracts,\n      contract => contract.address === contractAddress\n    )[0]\n  }\n\n  /**\n   * Adds new evidence to the store for a users contract. NOTE this will only update the\n   * stored evidence for the specified user, not all parties of the dispute.\n   * @param {string} contractAddress - Address of the contract\n   * @param {string} userAddress - Address of the user.\n   * @param {string} arbitrableTransactionIndex - Id of the arbitrable transaction.\n   * @param {string} name - Name of evidence.\n   * @param {string} description - Description of evidence.\n   * @param {string} url - A link to the evidence.\n   * @param {string} hash - The hash of the evidence.\n   * @returns {number} - The index of the evidence\n   */\n  addEvidenceContract = async (\n    contractAddress,\n    userAddress,\n    arbitrableTransactionIndex,\n    name,\n    description,\n    url,\n    hash\n  ) => {\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            name,\n            description,\n            URI: url,\n            hash\n          })\n        )\n      )\n\n    const response = await this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${\n        this._storeUri\n      }/${userAddress}/contracts/${contractAddress}/arbitrable-transaction/${arbitrableTransactionIndex}/evidence`\n    )\n\n    if (response.status !== 201)\n      throw new Error(\n        errorConstants.REQUEST_FAILED('Unable to submit evidence')\n      )\n\n    return response.body.evidenceIndex\n  }\n\n  /**\n   * Update stored dispute data for a user. Note this will not overwrite data.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} arbitratorAddress - The address of the arbitrator contract.\n   * @param {number} disputeID - The index of the dispute.\n   * @param {object} params - The dispute data we are updating.\n   * @returns {Promise} The resulting dispute data.\n   */\n  updateDisputeProfile = (\n    userAddress,\n    arbitratorAddress,\n    disputeID,\n    params\n  ) => {\n    const getBodyFn = async () => {\n      const userProfile = await this.newUserProfile(userAddress)\n\n      const currentDisputeProfile =\n        _.filter(\n          userProfile.disputes,\n          dispute =>\n            dispute.arbitratorAddress === arbitratorAddress &&\n            dispute.disputeId === disputeID\n        )[0] || {}\n\n      delete currentDisputeProfile._id\n      // set these so if it is a new dispute they are included\n      params.disputeId = disputeID\n      params.arbitratorAddress = arbitratorAddress\n\n      return JSON.stringify({ ...currentDisputeProfile, ...params })\n    }\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${\n        this._storeUri\n      }/${userAddress}/arbitrators/${arbitratorAddress}/disputes/${disputeID}`\n    )\n  }\n\n  /**\n   * Adds draws for juror to dispute profile.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} arbitratorAddress - The address of the arbitrator contract.\n   * @param {number} disputeID - The index of the dispute.\n   * @param {number[]} draws - The draws the juror has.\n   * @param {number} appeal - The appeal for which it is for.\n   * @returns {Promise} The resulting dispute data.\n   */\n  addNewDrawsDisputeProfile = (\n    userAddress,\n    arbitratorAddress,\n    disputeID,\n    draws,\n    appeal\n  ) => {\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            draws,\n            appeal\n          })\n        )\n      )\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${\n        this._storeUri\n      }/${userAddress}/arbitrators/${arbitratorAddress}/disputes/${disputeID}/draws`\n    )\n  }\n\n  /**\n   * Create a new notification in the store.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} txHash - The transaction hash which produced this event log. Used as an identifier.\n   * @param {number} logIndex - The index of the log in the transaction. Used as an identifier.\n   * @param {number} notificationType - The type of the notification. See constants/notification.\n   * @param {string} message - The message to be stored with the notification.\n   * @param {object} data - Any extra data stored with the notification.\n   * @param {boolean} read - If the notification has been read or not.\n   * @returns {Promise} - The resulting notification.\n   */\n  newNotification = async (\n    userAddress,\n    txHash,\n    logIndex,\n    notificationType,\n    message = '',\n    data = {},\n    read = false\n  ) => {\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            notificationType,\n            logIndex,\n            read,\n            message,\n            data\n          })\n        )\n      )\n\n    return this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/notifications/${txHash}`\n    )\n  }\n\n  /**\n   * Create a new notification in the store.\n   * @param {string} userAddress - The address of the user.\n   * @param {string} txHash - The transaction hash which produced this event log. Used as an identifier.\n   * @param {number} logIndex - The index of the log in the transaction. Used as an identifier.\n   * @param {boolean} isRead - If the notification has been read or not.\n   * @returns {Promise} - The resulting notification.\n   */\n  markNotificationAsRead = async (\n    userAddress,\n    txHash,\n    logIndex,\n    isRead = true\n  ) => {\n    const getBodyFn = () =>\n      new Promise(resolve =>\n        resolve(\n          JSON.stringify({\n            logIndex,\n            isRead\n          })\n        )\n      )\n\n    const result = await this.queueWriteRequest(\n      getBodyFn,\n      'POST',\n      `${this._storeUri}/${userAddress}/notifications/${txHash}/read`\n    )\n    return result.body.notifications\n  }\n}\n\nexport default StoreProviderWrapper\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/StoreProviderWrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 318,
    "kind": "class",
    "name": "StoreProviderWrapper",
    "memberof": "src/utils/StoreProviderWrapper.js",
    "static": true,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/StoreProviderWrapper.js",
    "importStyle": "StoreProviderWrapper",
    "description": "A wrapper for interacting with Kleros Store.",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 319,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#constructor",
    "access": "public",
    "description": "Create a new instance of StoreProviderWrapper.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "storeProviderUri",
        "description": "The uri of kleros store."
      }
    ]
  },
  {
    "__docId__": 320,
    "kind": "member",
    "name": "_storeUri",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#_storeUri",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "member",
    "name": "_storeQueue",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#_storeQueue",
    "access": "private",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "member",
    "name": "_cachedProfiles",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#_cachedProfiles",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "member",
    "name": "queueWriteRequest",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#queueWriteRequest",
    "access": "public",
    "description": "use the queue for write request. this allows a function to be passed so we can read immediately before we write",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{promise} promise that returns result of request. wait on this if you need it to be syncronous"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "fn"
        ],
        "spread": false,
        "optional": false,
        "name": "getBodyFn",
        "description": "async function to call before we write. Should to reads and return JSON to be used as body."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verb",
        "description": "POST or PUT"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uri",
        "description": "uri to call"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The users ETH address. Used to clear cache."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "promise"
      ],
      "spread": false,
      "description": "promise that returns result of request. wait on this if you need it to be syncronous"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "member",
    "name": "queueReadRequest",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#queueReadRequest",
    "access": "public",
    "description": "If we know we are waiting on some other write before we want to read we can add a read request to the end of the queue.",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} promise of the result function"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uri",
        "description": "uri to hit"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "promise of the result function"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "member",
    "name": "getMetaEvidenceUri",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getMetaEvidenceUri",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "member",
    "name": "getEvidenceUri",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getEvidenceUri",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "member",
    "name": "getUserProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getUserProfile",
    "access": "public",
    "description": "Fetch stored user profile.",
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - a response object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a response object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "member",
    "name": "getContractByAddress",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getContractByAddress",
    "access": "public",
    "description": "Fetch stored data on a contract for a user.",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - Contact data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "addressContract",
        "description": "The address of the contract."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Contact data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "member",
    "name": "getDispute",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getDispute",
    "access": "public",
    "description": "Get all stored data for a dispute. Must exist in User Profile.",
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - a response object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "Address of arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "Index of the dispute."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a response object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "member",
    "name": "getDisputes",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getDisputes",
    "access": "public",
    "description": "Fetch stored disputes for a user.",
    "lineNumber": 129,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - a response object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "a response object."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "member",
    "name": "getLastBlock",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#getLastBlock",
    "access": "public",
    "description": "Fetch the last block seen for a user. This is commonly used with EventListerer.",
    "lineNumber": 144,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The last block number."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The last block number."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "member",
    "name": "newUserProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#newUserProfile",
    "access": "public",
    "description": "Set up a new user profile if one does not exist.",
    "lineNumber": 165,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - users existing or created profile"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "user's address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "users existing or created profile"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "member",
    "name": "updateLastBlock",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#updateLastBlock",
    "access": "public",
    "description": "Update users last block seen. This is the only item in user profile that can be overwritten.",
    "lineNumber": 185,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - HTTP response."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "User's address."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "blockNumber",
        "description": "The newest block number seen by user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "HTTP response."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "member",
    "name": "updateUserSession",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#updateUserSession",
    "access": "public",
    "description": "Update users last processed session.",
    "lineNumber": 208,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - HTTP response."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "User's address."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "The current session that the user has processed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "HTTP response."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "member",
    "name": "updateContract",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#updateContract",
    "access": "public",
    "description": "Update the stored data on a contract for a user. Note that you cannot overwrite contract data.",
    "lineNumber": 232,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The resulting contract data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The user's address."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "The address of the contract."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Params we want to update."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting contract data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 336,
    "kind": "member",
    "name": "addEvidenceContract",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#addEvidenceContract",
    "access": "public",
    "description": "Adds new evidence to the store for a users contract. NOTE this will only update the\nstored evidence for the specified user, not all parties of the dispute.",
    "lineNumber": 270,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The index of the evidence"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "contractAddress",
        "description": "Address of the contract"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "Address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitrableTransactionIndex",
        "description": "Id of the arbitrable transaction."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "Description of evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "A link to the evidence."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "The hash of the evidence."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The index of the evidence"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "member",
    "name": "updateDisputeProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#updateDisputeProfile",
    "access": "public",
    "description": "Update stored dispute data for a user. Note this will not overwrite data.",
    "lineNumber": 315,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} The resulting dispute data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "The dispute data we are updating."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting dispute data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "member",
    "name": "addNewDrawsDisputeProfile",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#addNewDrawsDisputeProfile",
    "access": "public",
    "description": "Adds draws for juror to dispute profile.",
    "lineNumber": 358,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} The resulting dispute data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "arbitratorAddress",
        "description": "The address of the arbitrator contract."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "disputeID",
        "description": "The index of the dispute."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "draws",
        "description": "The draws the juror has."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "appeal",
        "description": "The appeal for which it is for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting dispute data."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "member",
    "name": "newNotification",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#newNotification",
    "access": "public",
    "description": "Create a new notification in the store.",
    "lineNumber": 395,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The resulting notification."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "The transaction hash which produced this event log. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "The index of the log in the transaction. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "notificationType",
        "description": "The type of the notification. See constants/notification."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "The message to be stored with the notification."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Any extra data stored with the notification."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "read",
        "description": "If the notification has been read or not."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting notification."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 340,
    "kind": "member",
    "name": "markNotificationAsRead",
    "memberof": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper",
    "static": false,
    "longname": "src/utils/StoreProviderWrapper.js~StoreProviderWrapper#markNotificationAsRead",
    "access": "public",
    "description": "Create a new notification in the store.",
    "lineNumber": 432,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The resulting notification."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userAddress",
        "description": "The address of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "txHash",
        "description": "The transaction hash which produced this event log. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logIndex",
        "description": "The index of the log in the transaction. Used as an identifier."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isRead",
        "description": "If the notification has been read or not."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The resulting notification."
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "file",
    "name": "src/utils/Web3Wrapper.js",
    "content": "import _ from 'lodash'\nimport Web3 from 'web3'\n\nclass Web3Wrapper {\n  /**\n   * Constructor Web3 wrapper.\n   * @param {object} web3Provider - The web3 instance.\n   */\n  constructor(web3Provider) {\n    this._web3 = new Web3(web3Provider)\n  }\n\n  isAddress = address => this._web3.isAddress(address)\n\n  getAccount = index => this._web3.eth.accounts[index]\n\n  getProvider = () => this._web3.currentProvider\n\n  getCoinbase = () => this._web3.eth.coinbase\n\n  getNonce = async address => {\n    const nonce = await this._web3.eth.getTransactionCount(address)\n    return nonce\n  }\n\n  toWei = (amount, unit) => {\n    const newAmount = this._web3.toWei(amount, unit)\n    return newAmount.toNumber ? newAmount.toNumber() : Number(newAmount)\n  }\n\n  fromWei = (amount, unit) => {\n    const newAmount = this._web3.fromWei(amount, unit)\n    return newAmount.toNumber ? newAmount.toNumber() : Number(newAmount)\n  }\n\n  toBigNumber = number => this._web3.toBigNumber(number)\n\n  blockNumber = () => this._web3.eth.blockNumber\n\n  sign = (userAddress, data) =>\n    new Promise((resolve, reject) => {\n      this._web3.eth.sign(userAddress, data, (error, result) => {\n        if (error) reject(error)\n\n        resolve(result)\n      })\n    })\n\n  getBlock = blockNumber =>\n    new Promise((resolve, reject) => {\n      this._web3.eth.getBlock(blockNumber, (error, result) => {\n        if (error) reject(error)\n\n        resolve(result)\n      })\n    })\n\n  doesContractExistAtAddressAsync = async address => {\n    const code = await this._web3.eth.getCode(address)\n    // Regex matches 0x0, 0x00, 0x in order to accommodate poorly implemented clients\n    const codeIsEmpty = /^0x0{0,40}$/i.test(code)\n\n    return !codeIsEmpty\n  }\n\n  _getNetworkIdIfExistsAsync = async () => {\n    if (!_.isUndefined(this.networkIdIfExists)) {\n      return this.networkIdIfExists\n    }\n\n    try {\n      const networkId = await this._getNetworkAsync()\n\n      this.networkIdIfExists = Number(networkId)\n      return this.networkIdIfExists\n    } catch (err) {\n      console.log(err)\n      return undefined\n    }\n  }\n\n  _getNetworkAsync = async () => {\n    const networkId = await this._web3.version.network\n\n    return networkId\n  }\n\n  getBalanceInWeiAsync = owner => {\n    if (_.isUndefined(owner)) {\n      owner = this._web3.eth.accounts[0]\n    }\n\n    let balanceInWei = this._web3.eth.getBalance(owner)\n\n    return balanceInWei.toString()\n  }\n}\n\nexport default Web3Wrapper\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/Web3Wrapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 342,
    "kind": "class",
    "name": "Web3Wrapper",
    "memberof": "src/utils/Web3Wrapper.js",
    "static": true,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/Web3Wrapper.js",
    "importStyle": "Web3Wrapper",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 343,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#constructor",
    "access": "public",
    "description": "Constructor Web3 wrapper.",
    "lineNumber": 9,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "The web3 instance."
      }
    ]
  },
  {
    "__docId__": 344,
    "kind": "member",
    "name": "_web3",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#_web3",
    "access": "private",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "member",
    "name": "isAddress",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#isAddress",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "member",
    "name": "getAccount",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getAccount",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "member",
    "name": "getProvider",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getProvider",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "member",
    "name": "getCoinbase",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getCoinbase",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "member",
    "name": "getNonce",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getNonce",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "member",
    "name": "toWei",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#toWei",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "member",
    "name": "fromWei",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#fromWei",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 352,
    "kind": "member",
    "name": "toBigNumber",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#toBigNumber",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 353,
    "kind": "member",
    "name": "blockNumber",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#blockNumber",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "member",
    "name": "sign",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#sign",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "member",
    "name": "getBlock",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getBlock",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 356,
    "kind": "member",
    "name": "doesContractExistAtAddressAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#doesContractExistAtAddressAsync",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "member",
    "name": "_getNetworkIdIfExistsAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#_getNetworkIdIfExistsAsync",
    "access": "private",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "member",
    "name": "networkIdIfExists",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#networkIdIfExists",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "member",
    "name": "_getNetworkAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#_getNetworkAsync",
    "access": "private",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "getBalanceInWeiAsync",
    "memberof": "src/utils/Web3Wrapper.js~Web3Wrapper",
    "static": false,
    "longname": "src/utils/Web3Wrapper.js~Web3Wrapper#getBalanceInWeiAsync",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "file",
    "name": "src/utils/delegateCalls.js",
    "content": "import _ from 'lodash'\n\n/**\n * delegate calls from a baseClass to a providerClass if the call does not exist in base class\n * @param {object} baseClass - The base object that has first priority to make calls\n * @param {object} providerClass - The class whose methods will be called by baseClass\n * @param {function} middlewareCall - <optional> Middleware function that can act as\n * intermediary between base and provider. Should take a two params which is the provider\n * classes method call and the params passed\n */\nconst delegateCalls = (baseClass, providerClass, middlewareCall) => {\n  // we don't want to delegate any calls that are part of the base class\n  const existingMethods = Object.getOwnPropertyNames(baseClass).concat(\n    Object.getPrototypeOf(baseClass)\n  )\n  // methods of provider\n  const providerMethods = Object.getOwnPropertyNames(providerClass)\n  // calls we will delegate\n  const delegatableMethods = providerMethods.filter(method => {\n    if (\n      !providerClass.hasOwnProperty(method) ||\n      typeof providerClass[method] !== 'function'\n    ) {\n      return false\n    }\n\n    return !_.includes(existingMethods, method)\n  })\n\n  // delegate calls in baseClass\n  delegatableMethods.forEach(methodName => {\n    let curriedCall\n    if (middlewareCall)\n      curriedCall = (...args) =>\n        middlewareCall(providerClass[methodName], ...args)\n    else curriedCall = (...args) => providerClass[methodName](...args)\n    // set method in baseClass\n    baseClass[methodName] = curriedCall\n  })\n}\n\n/**\n{ constant: true,\n  inputs: [],\n  name: 'lastPeriodChange',\n  outputs: [ [Object] ],\n  payable: false,\n  stateMutability: 'view',\n  type: 'function' },\n*/\n\nexport default delegateCalls\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/delegateCalls.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 362,
    "kind": "function",
    "name": "delegateCalls",
    "memberof": "src/utils/delegateCalls.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/delegateCalls.js~delegateCalls",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/delegateCalls.js",
    "importStyle": "delegateCalls",
    "description": "{ constant: true,\ninputs: [],\nname: 'lastPeriodChange',\noutputs: [ [Object] ],\npayable: false,\nstateMutability: 'view',\ntype: 'function' },",
    "lineNumber": 11,
    "params": [
      {
        "name": "baseClass",
        "types": [
          "*"
        ]
      },
      {
        "name": "providerClass",
        "types": [
          "*"
        ]
      },
      {
        "name": "middlewareCall",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 363,
    "kind": "file",
    "name": "src/utils/deployContractAsync.js",
    "content": "import contract from 'truffle-contract'\n\nimport * as ethConstants from '../constants/eth'\nimport { UNABLE_TO_DEPLOY_CONTRACT } from '../constants/error'\n\nimport isRequired from './isRequired'\n\n/**\n * Deploy a contract on the Ethereum network using the contract artifact.\n * @param {string} account - The account to deploy it under.\n * @param {number} value - The value to send.\n * @param {object} artifact - JSON artifact of the contract.\n * @param {object} web3Provider - Web3 Provider object (NOTE NOT Kleros Web3Wrapper)\n * @param {...any} args - Extra arguments.\n * @returns {object} - truffle-contract Object | err The contract object or an error\n */\nconst deployContractAsync = async (\n  account = isRequired('account'),\n  value = isRequired('value'),\n  artifact = isRequired('artifact'),\n  web3Provider = isRequired('web3Provider'),\n  ...args\n) => {\n  try {\n    const MyContract = contract({\n      abi: artifact.abi,\n      unlinked_binary: artifact.bytecode\n        ? artifact.bytecode\n        : artifact.unlinked_binary\n    })\n    MyContract.setProvider(web3Provider)\n\n    return MyContract.new(...args, {\n      from: account,\n      value: value,\n      gas: ethConstants.TRANSACTION.GAS\n    })\n  } catch (err) {\n    console.error(err)\n    throw new Error(UNABLE_TO_DEPLOY_CONTRACT)\n  }\n}\n\nexport default deployContractAsync\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/deployContractAsync.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 364,
    "kind": "function",
    "name": "deployContractAsync",
    "memberof": "src/utils/deployContractAsync.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/utils/deployContractAsync.js~deployContractAsync",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/deployContractAsync.js",
    "importStyle": "deployContractAsync",
    "description": "Deploy a contract on the Ethereum network using the contract artifact.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - truffle-contract Object | err The contract object or an error"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "account",
        "description": "The account to deploy it under."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The value to send."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "artifact",
        "description": "JSON artifact of the contract."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "web3Provider",
        "description": "Web3 Provider object (NOTE NOT Kleros Web3Wrapper)"
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Extra arguments."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "truffle-contract Object | err The contract object or an error"
    }
  },
  {
    "__docId__": 365,
    "kind": "file",
    "name": "src/utils/getContractAddress.js",
    "content": "import ethUtil from 'ethereumjs-util'\n\nconst getContractAddress = (account, nonce) =>\n  ethUtil.bufferToHex(ethUtil.generateAddress(account, nonce))\n\nexport default getContractAddress\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/getContractAddress.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 366,
    "kind": "function",
    "name": "getContractAddress",
    "memberof": "src/utils/getContractAddress.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/getContractAddress.js~getContractAddress",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/getContractAddress.js",
    "importStyle": "getContractAddress",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "account",
        "types": [
          "*"
        ]
      },
      {
        "name": "nonce",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 367,
    "kind": "file",
    "name": "src/utils/httpRequest.js",
    "content": "import * as errorConstants from '../constants/error'\n\n/**\n * Helper method for sending an http requests.\n * @param {string} verb - HTTP verb to be used in request. E.g. GET, POST, PUT.\n * @param {string} uri - The uri to send the request to.\n * @param {string} body - json string of the body.\n * @returns {Promise} request promise that resolves to the HTTP response.\n */\nconst httpRequest = (verb, uri, body = null) => {\n  const httpRequest = new XMLHttpRequest()\n  return new Promise((resolve, reject) => {\n    try {\n      httpRequest.open(verb, uri, true)\n      if (body) {\n        httpRequest.setRequestHeader(\n          'Content-Type',\n          'application/json;charset=UTF-8'\n        )\n      }\n      httpRequest.onreadystatechange = () => {\n        if (httpRequest.readyState === 4) {\n          let body = null\n          try {\n            body = JSON.parse(httpRequest.responseText)\n            // eslint-disable-next-line no-unused-vars\n          } catch (err) {}\n          resolve({\n            body: body,\n            status: httpRequest.status\n          })\n        }\n      }\n      httpRequest.send(body)\n    } catch (err) {\n      reject(errorConstants.REQUEST_FAILED(err))\n    }\n  })\n}\n\nexport default httpRequest\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/httpRequest.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 368,
    "kind": "function",
    "name": "httpRequest",
    "memberof": "src/utils/httpRequest.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/httpRequest.js~httpRequest",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/httpRequest.js",
    "importStyle": "httpRequest",
    "description": "Helper method for sending an http requests.",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} request promise that resolves to the HTTP response."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verb",
        "description": "HTTP verb to be used in request. E.g. GET, POST, PUT."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uri",
        "description": "The uri to send the request to."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "body",
        "description": "json string of the body."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "request promise that resolves to the HTTP response."
    }
  },
  {
    "__docId__": 369,
    "kind": "file",
    "name": "src/utils/isRequired.js",
    "content": "import { MISSING_PARAMETERS } from '../constants/error'\n\n/**\n * Used as the default parameter for an arguemnt that is considered required. It will\n * throw an error if the argument is not supplied by the user.\n * @param {string} name - The name of the missing argument.\n */\nconst isRequired = name => {\n  throw new Error(MISSING_PARAMETERS(name))\n}\n\nexport default isRequired\n",
    "static": true,
    "longname": "/Users/samvitello/kleros/kleros-api/src/utils/isRequired.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 370,
    "kind": "function",
    "name": "isRequired",
    "memberof": "src/utils/isRequired.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/isRequired.js~isRequired",
    "access": "public",
    "export": true,
    "importPath": "kleros-api/src/utils/isRequired.js",
    "importStyle": "isRequired",
    "description": "Used as the default parameter for an arguemnt that is considered required. It will\nthrow an error if the argument is not supplied by the user.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the missing argument."
      }
    ],
    "return": null
  },
  {
    "kind": "index",
    "content": "# Kleros API\n\n<p align=\"center\">\n  <a href=\"https://badge.fury.io/js/kleros-api\"><img src=\"https://badge.fury.io/js/kleros-api.svg\" alt=\"NPM Version\"></a>\n  <a href=\"https://travis-ci.org/kleros/kleros-api\"><img src=\"https://travis-ci.org/kleros/kleros-api.svg?branch=master\" alt=\"Build Status\"></a>\n  <a href=\"https://coveralls.io/github/kleros/kleros-api?branch=master\"><img src=\"https://coveralls.io/repos/github/kleros/kleros-api/badge.svg?branch=master\" alt=\"Coverage Status\"></a>\n  <a href=\"https://david-dm.org/kleros/kleros-api\"><img src=\"https://david-dm.org/kleros/kleros-api.svg\" alt=\"Dependencies\"></a>\n  <a href=\"https://david-dm.org/kleros/kleros-api?type=dev\"><img src=\"https://david-dm.org/kleros/kleros-api/dev-status.svg\" alt=\"Dev Dependencies\"></a>\n  <a href=\"https://github.com/facebook/jest\"><img src=\"https://img.shields.io/badge/tested_with-jest-99424f.svg\" alt=\"Tested with Jest\"></a>\n  <a href=\"https://standardjs.com\"><img src=\"https://img.shields.io/badge/code_style-standard-brightgreen.svg\" alt=\"JavaScript Style Guide\"></a>\n  <a href=\"https://github.com/prettier/prettier\"><img src=\"https://img.shields.io/badge/styled_with-prettier-ff69b4.svg\" alt=\"Styled with Prettier\"></a>\n  <a href=\"https://conventionalcommits.org\"><img src=\"https://img.shields.io/badge/Conventional%20Commits-1.0.0-yellow.svg\" alt=\"Conventional Commits\"></a>\n  <a href=\"http://commitizen.github.io/cz-cli/\"><img src=\"https://img.shields.io/badge/commitizen-friendly-brightgreen.svg\" alt=\"Commitizen Friendly\"></a>\n</p>\n\n> This repository contains a Javascript library that provides methods to interact with Kleros arbitrator\n> and Arbitrable contracts. It can be used to develop Relayers or DApps that use Kleros smart contracts.\n\n## Installation\n\n```\nyarn add kleros-api\n```\n\n## Basic Usage\n\nSee the full API docs [here](https://kleros.io/kleros-api/).\n\nThe base Kleros object initializes all of the different kleros api's with the contract\naddresses you pass. This object is useful if your application interacts with both arbitrators,\narbitrable contracts and uses an off chain store to provide metadata on the different disputes\nfor the UI.\n\n```\n// pay arbitration fee.\nimport Kleros from 'kleros-api'\n\nconst KlerosInstance = new Kleros(\n  ETH_PROVIDER, // ethereum provider object\n  KLEROS_STORE_URI, // uri of off chain storage e.g. https://kleros.in\n  ARITRATOR_CONTRACT_ADDRESS, // address of a deployed Kleros arbitrator contract\n  ARBITRABLE_CONTRACT_ADDRESS // address of a deployed arbitrable transaction contract\n)\n\nKlerosInstance.arbitrable.payArbitrationFeeByPartyA() // pay arbitration fee for an arbitrable contract\n```\n\nYou can also use the specific api that best suits your needs.\n\n```\n// deploy a new contract and pay the arbitration fee.\nimport ArbitrableTransaction from 'kleros-api/contracts/implementations/arbitrable/ArbitrableTransaction'\n\n// deploy methods are static\nconst contractInstance = ArbitrableTransaction.deploy(\n    \"0x67a3f2BB8B4B2060875Bd6543156401B817bEd22\", // users address\n    0.15, // amount of ETH to escrow\n    \"0x0\", // hash of the off chain contract\n    \"0x3af76ef44932695a33ba2af52018cd24a74c904f\", // arbitrator address\n    3600, // number of seconds until there is a timeout\n    \"0x0474b723bd4986808366E0DcC2E301515Aa742B4\", // the other party in the contract\n    \"0x0\", // extra data in bytes. This can be used to interact with the arbitrator contract\n    ETH_PROVIDER, // provider object to be used to interact with the network\n  )\n\nconst address = contractInstance.address // get the address of your newly created contract\n\nconst ArbitrableTransactionInstance = new ArbitrableTransaction(address) // instantiate instance of the api\n\nArbitrableTransactionInstance.payArbitrationFeeByPartyA() // pay arbitration fee\n```\n\n## Development\n\nIf you want to contribute to our api or modify it for your usage\n\n## Setup\n\nWe assume that you have node and yarn installed.\n\n```sh\nyarn install\n```\n\n## Test\n\n```sh\nyarn ganache\nyarn test\n```\n\n## Build\n\n```sh\nyarn run build\n```\n",
    "longname": "/Users/samvitello/kleros/kleros-api/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"kleros-api\",\n  \"version\": \"0.18.7\",\n  \"description\": \"A Javascript library that makes it easy to build relayers and other DApps that use the Kleros protocol.\",\n  \"keywords\": [\n    \"Blockchain\",\n    \"Ethereum\",\n    \"Kleros\"\n  ],\n  \"main\": \"lib/index.js\",\n  \"module\": \"es/index.js\",\n  \"files\": [\n    \"es\",\n    \"lib\",\n    \"umd\"\n  ],\n  \"homepage\": \"https://kleros.io\",\n  \"repository\": \"github:kleros/kleros-api\",\n  \"bugs\": \"https://github.com/kleros/kleros-api/issues\",\n  \"author\": \"Kleros Team <contact@kleros.io> (https://github.com/kleros)\",\n  \"contributors\": [\n    \"Wagner Nicolas <nicolas@kleros.io> (https://github.com/n1c01a5)\",\n    \"Sam Vitello (https://github.com/satello)\",\n    \"Enrique Piqueras <enrique@kleros.io> (https://github.com/epiqueras)\"\n  ],\n  \"license\": \"MIT\",\n  \"private\": false,\n  \"scripts\": {\n    \"docs\": \"esdoc\",\n    \"prettify\": \"kleros-scripts prettify\",\n    \"lint\": \"kleros-scripts lint:js --config ./.eslintrc.js\",\n    \"ganache\": \"ganache-cli -a 15 -s 1\",\n    \"test\": \"GAS=3000000 jest --config ./jest.config.js\",\n    \"test:coveralls\": \"coveralls < ./coverage/lcov.info\",\n    \"commitmsg\": \"kleros-scripts commitmsg\",\n    \"cz\": \"kleros-scripts cz\",\n    \"start\": \"babel src --out-dir ./es --watch --source-maps\",\n    \"build\": \"rimraf ./umd ./es ./lib && webpack --env.NODE_ENV=production -p && babel src --out-dir ./es --source-maps && cross-env BABEL_ENV=commonjs babel src --out-dir ./lib --source-maps\"\n  },\n  \"commitlint\": {\n    \"extends\": [\n      \"@commitlint/config-conventional\"\n    ]\n  },\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-core\": \"^6.26.0\",\n    \"babel-jest\": \"^22.4.1\",\n    \"babel-loader\": \"^7.1.3\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"babel-preset-stage-2\": \"^6.24.1\",\n    \"coveralls\": \"^3.0.0\",\n    \"cross-env\": \"^5.1.4\",\n    \"esdoc\": \"^1.0.4\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"ganache-cli\": \"^6.1.8\",\n    \"husky\": \"^0.14.3\",\n    \"jest\": \"^22.4.2\",\n    \"kleros-scripts\": \"^0.4.0\",\n    \"rimraf\": \"^2.6.2\",\n    \"standard-version\": \"^4.3.0\",\n    \"webpack\": \"^4.0.1\",\n    \"webpack-cli\": \"^2.0.9\"\n  },\n  \"dependencies\": {\n    \"babel-runtime\": \"^6.26.0\",\n    \"eth-sig-util\": \"^1.4.2\",\n    \"ethereumjs-util\": \"^5.2.0\",\n    \"ethjs\": \"^0.4.0\",\n    \"kleros\": \"^0.0.6\",\n    \"kleros-interaction\": \"^0.0.26\",\n    \"lodash\": \"^4.17.4\",\n    \"minimetoken\": \"^0.2.0\",\n    \"truffle-contract\": \"^2.0.5\",\n    \"web3\": \"^0.20.1\",\n    \"web3-eth-personal\": \"^1.0.0-beta.34\"\n  }\n}\n",
    "longname": "/Users/samvitello/kleros/kleros-api/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]